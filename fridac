#!/usr/bin/env python3
"""
fridac - å¢å¼ºç‰ˆ Frida CLI å·¥å…·ï¼Œå¸¦äº¤äº’å¼ JavaScript Shellï¼ˆæ¨¡å—åŒ–ç‰ˆæœ¬ï¼‰

ç”¨æ³•:
  fridac                              # æ™ºèƒ½æ¨¡å¼è‡ªåŠ¨é™„åŠ åˆ°å‰å°åº”ç”¨
  fridac -a                           # æ˜¾ç¤ºåº”ç”¨åˆ—è¡¨ä¾›é€‰æ‹©
  fridac -f com.example.app           # ä»¥ Spawn æ¨¡å¼å¯åŠ¨å¹¶é™„åŠ ï¼ˆç­‰åŒ frida -U -f com.example.appï¼‰
  fridac -p com.example.app           # é™„åŠ åˆ°æŒ‡å®šåŒ…ï¼ˆç­‰åŒ frida -U com.example.appï¼‰
  fridac --spawn com.example.app      # Spawn æ¨¡å¼ï¼ˆåŒ -fï¼‰

ç‰¹æ€§:
- å¸¦è‡ªåŠ¨è¡¥å…¨çš„äº¤äº’å¼ JavaScript Shell
- è‡ªåŠ¨è®¾å¤‡æ£€æµ‹ä¸è¿æ¥
- æ™ºèƒ½åŒ…åå¤„ç†
- å†…ç½®è¿½è¸ªä¸è°ƒè¯•åŠŸèƒ½
- è‡ªåŠ¨ä»»åŠ¡è¿½è¸ªç³»ç»Ÿ
- Rich UI æ”¯æŒ

è‡ªåŠ¨æ£€æµ‹ pyenv çš„ Python ç‰ˆæœ¬å¹¶é€‰æ‹©å¯¹åº”çš„ Frida:
- Python 3.6.8 -> Frida 14.x
- Python 3.8.2 -> Frida 16.x
"""

import sys
import os
import argparse
import signal
import traceback
import json
import time

# å°† fridac_core åŒ…åŠ å…¥ Python è·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from fridac_core.logger import show_banner, log_info, log_success, log_error, log_warning, log_exception, log_debug
from fridac_core.environment import (
    detect_python_environment, 
    get_frida_version, 
    get_frontmost_app, 
    find_target_app,
    show_environment_info
)
from fridac_core.session import FridacSession, run_interactive_session

def _load_early_hooks_config(config_file=None):
    """åŠ è½½æ—©æœŸ hook é…ç½®æ–‡ä»¶"""
    if not config_file:
        config_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'early_hooks.json')
    
    if not os.path.exists(config_file):
        log_warning(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_file}")
        return {}
    
    try:
        with open(config_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        log_error(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
        return {}

def _execute_single_hook(session, hook_name, args_list):
    """æ‰§è¡Œå•ä¸ª hook å‡½æ•°"""
    try:
        # é¦–å…ˆéªŒè¯å‡½æ•°æ˜¯å¦å­˜åœ¨
        check_js = f"typeof {hook_name} !== 'undefined'"
        result = session.script.exports.eval(check_js)
        
        if not result:
            log_error(f"âŒ å‡½æ•° {hook_name} æœªæ‰¾åˆ°æˆ–æœªæ­£ç¡®åŠ è½½")
            # å°è¯•é€šè¿‡ RPC è°ƒç”¨
            if hasattr(session.script.exports, hook_name):
                log_info(f"ğŸ”„ å°è¯•é€šè¿‡ RPC è°ƒç”¨ {hook_name}")
                rpc_func = getattr(session.script.exports, hook_name)
                if args_list:
                    rpc_func(*args_list)
                else:
                    rpc_func()
                return True
            else:
                return False
        
        if hook_name == "traceRegisterNatives":
            # ç‰¹æ®Šå¤„ç† traceRegisterNatives
            target_so = args_list[0] if args_list else ""
            js_call = f"traceRegisterNatives('{target_so}')" if target_so else "traceRegisterNatives()"
        else:
            # é€šç”¨ hook å¤„ç†
            if args_list:
                formatted_args = ', '.join([f"'{arg}'" if not str(arg).isdigit() and str(arg).lower() not in ['true', 'false'] else str(arg) 
                                           for arg in args_list])
                js_call = f"{hook_name}({formatted_args})"
            else:
                js_call = f"{hook_name}()"
        
        log_info(f"ğŸ¯ æ‰§è¡Œ: {js_call}")
        session.execute_js(js_call)
        return True
    except Exception as e:
        log_error(f"âŒ æ‰§è¡Œå¤±è´¥: {hook_name} - {e}")
        return False

def _execute_early_hooks(session, early_hook, hook_args, preset, config_file):
    """æ‰§è¡Œæ—©æœŸ hook é…ç½®"""
    executed_count = 0
    
    # è°ƒè¯•ï¼šæ˜¾ç¤ºå¯ç”¨çš„å‡½æ•°
    try:
        available_funcs = session.script.exports.eval("Object.keys(rpc.exports).filter(k => typeof rpc.exports[k] === 'function')")
        log_info(f"ğŸ” å¯ç”¨çš„RPCå‡½æ•°: {len(available_funcs)} ä¸ª")
        
        # æ£€æŸ¥ traceRegisterNatives æ˜¯å¦å­˜åœ¨
        has_trace_natives = session.script.exports.eval("typeof traceRegisterNatives !== 'undefined'")
        log_info(f"ğŸ” traceRegisterNatives å‡½æ•°å­˜åœ¨: {has_trace_natives}")
        
        # æ£€æŸ¥æ˜¯å¦åœ¨ RPC å¯¼å‡ºä¸­
        in_rpc = session.script.exports.eval("'traceRegisterNatives' in rpc.exports")
        log_info(f"ğŸ” traceRegisterNatives åœ¨RPCå¯¼å‡ºä¸­: {in_rpc}")
        
        # å¦‚æœå‡½æ•°ä¸å­˜åœ¨ï¼Œå°è¯•æŸ¥çœ‹å…·ä½“åŸå› 
        if not has_trace_natives or not in_rpc:
            log_warning("âš ï¸  traceRegisterNatives å‡½æ•°åŠ è½½å¼‚å¸¸ï¼Œæ£€æŸ¥è‡ªå®šä¹‰è„šæœ¬...")
            custom_exports_check = session.script.exports.eval("typeof CUSTOM_EXPORTS_CODE !== 'undefined'")
            log_info(f"ğŸ” è‡ªå®šä¹‰å¯¼å‡ºä»£ç å­˜åœ¨: {custom_exports_check}")
            
    except Exception as e:
        log_error(f"âŒ è°ƒè¯•ä¿¡æ¯è·å–å¤±è´¥: {e}")
    
    # å¤„ç†å•ä¸ª hook
    if early_hook:
        log_info(f"ğŸš€ æ‰§è¡Œæ—©æœŸHook: {early_hook}")
        args_list = [arg.strip() for arg in hook_args.split(',')] if hook_args else []
        if _execute_single_hook(session, early_hook, args_list):
            executed_count += 1
            log_success(f"âœ… æ—©æœŸHookå·²æ‰§è¡Œ: {early_hook}")
    
    # å¤„ç†é¢„è®¾
    if preset:
        log_info(f"ğŸ¯ åŠ è½½Hooké¢„è®¾: {preset}")
        config = _load_early_hooks_config(config_file)
        presets = config.get('presets', {})
        
        if preset in presets:
            preset_config = presets[preset]
            log_info(f"ğŸ“‹ é¢„è®¾æè¿°: {preset_config.get('description', 'æ— æè¿°')}")
            
            hooks = preset_config.get('hooks', [])
            for hook_config in hooks:
                hook_name = hook_config.get('function')
                hook_args = hook_config.get('args', [])
                hook_desc = hook_config.get('description', '')
                
                if hook_desc:
                    log_info(f"   {hook_desc}")
                
                if _execute_single_hook(session, hook_name, hook_args):
                    executed_count += 1
                
                # çŸ­æš‚å»¶è¿Ÿï¼Œç¡®ä¿ hook è®¾ç½®å®Œæˆ
                time.sleep(0.1)
            
            log_success(f"âœ… é¢„è®¾ '{preset}' å·²åŠ è½½ï¼Œæ‰§è¡Œäº† {len(hooks)} ä¸ªHook")
        else:
            log_error(f"âŒ æœªæ‰¾åˆ°é¢„è®¾: {preset}")
            available = list(presets.keys())
            if available:
                log_info(f"å¯ç”¨é¢„è®¾: {', '.join(available)}")
    
    if executed_count > 0:
        log_success(f"ğŸ‰ æ—©æœŸHookæ‰§è¡Œå®Œæˆï¼Œå…±æ‰§è¡Œ {executed_count} ä¸ªHook")
        log_info("â³ ç­‰å¾…åº”ç”¨è§¦å‘Hook...")

def run_frida_session(spawn_mode=False, target_package=None, force_show_apps=False, early_hook=None, hook_args=None, preset=None, config_file=None, output_file=None, append_mode=False):
    """è¿è¡Œ Frida ä¼šè¯ï¼ˆå¸¦äº¤äº’å¼ Shellï¼‰"""
    
    if force_show_apps or not target_package:
        # äº¤äº’å¼æŸ¥æ‰¾ç›®æ ‡åº”ç”¨
        target_app = find_target_app()
        if not target_app:
            return
    else:
        # ä½¿ç”¨æŒ‡å®šçš„åŒ…å
        target_app = target_package
        log_info("ä½¿ç”¨æŒ‡å®šçš„åŒ…å: {}".format(target_app))
    
    session = FridacSession()
    
    # è®¾ç½®è¾“å‡ºé‡å®šå‘
    if output_file:
        session.setup_output_redirect(output_file, append_mode)
        log_info(f"ğŸ“ Hookè¾“å‡ºå°†é‡å®šå‘åˆ°: {output_file} ({'è¿½åŠ ' if append_mode else 'è¦†ç›–'}æ¨¡å¼)")
    
    # å®‰è£…ä¿¡å·å¤„ç†å™¨ä»¥ä¼˜é›…é€€å‡º
    def signal_handler(sig, frame):
        log_info("æ­£åœ¨é€€å‡º...")
        session.disconnect()
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    # è¿æ¥åˆ°åº”ç”¨
    if not session.connect_to_app(target_app, spawn_mode):
        return
    
    # æ‰§è¡Œæ—©æœŸ hookï¼ˆç¨ä½œå»¶è¿Ÿç¡®ä¿è„šæœ¬å®Œå…¨åŠ è½½ï¼‰
    if early_hook or preset:
        log_info("â³ ç­‰å¾…è„šæœ¬å®Œå…¨åŠ è½½...")
        time.sleep(0.5)  # ç­‰å¾…500msç¡®ä¿è„šæœ¬åŠ è½½å®Œæˆ
    
    _execute_early_hooks(session, early_hook, hook_args, preset, config_file)
    
    # è¿›å…¥äº¤äº’å¼ä¼šè¯
    try:
        run_interactive_session(session)
    except OSError as e:
        # æŸäº›ç¯å¢ƒï¼ˆé TTYã€ç®¡é“ç­‰ï¼‰ä¼šè§¦å‘ [Errno 22] Invalid argument
        log_exception("äº¤äº’ä¼šè¯ I/O å¼‚å¸¸", e)
    except Exception as e:
        # ä¸è®©å¼‚å¸¸å†’æ³¡åˆ°ä¸»å‡½æ•°ï¼Œé¿å…è¯¯æŠ¥â€œè¿è¡Œå‡ºé”™â€
        log_exception("äº¤äº’ä¼šè¯å‘ç”Ÿé”™è¯¯", e)
    finally:
        # æ¸…ç†
        session.disconnect()

def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description='fridac - Enhanced Frida CLI tool with interactive JavaScript shell',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  fridac                                    # Auto-attach to frontmost app (smart mode)
  fridac -a                                 # Show apps list for selection
  fridac -f com.example.app                 # Spawn app and attach
  fridac -p com.example.app                 # Attach to specific package
  fridac --spawn com.example.app            # Spawn app and attach (same as -f)
  
Early Hook Examples (spawn mode only):
  fridac -f com.app --hook traceRegisterNatives                    # Hook RegisterNatives immediately
  fridac -f com.app --hook traceRegisterNatives --hook-args mylib  # Hook specific SO
  fridac -f com.app --hook hookbase64                              # Hook Base64 operations
  fridac -f com.app --hook traceMethod --hook-args com.app.Class.method  # Hook specific method
  
Hook Presets (spawn mode only):
  fridac -f com.app --preset jni_analysis         # JNI analysis suite (RegisterNatives + Base64 + NewStringUTF)
  fridac -f com.app --preset crypto_analysis      # Crypto analysis suite (Base64 + JSON + crypto libs)
  fridac -f com.app --preset network_analysis     # Network analysis suite (URL + fetch + okhttp)
  fridac -f com.app --preset anti_debug          # Anti-debug analysis suite (RegisterNatives + file ops + logs)
  
Output Redirection:
  fridac -f com.app --hook traceRegisterNatives -o hooks.log        # Save output to file
  fridac -f com.app --preset jni_analysis -o analysis.log --append # Append to existing file
        '''
    )
    
    parser.add_argument('-f', '--package', type=str,
                       help='Specify package name to spawn and attach')
    
    parser.add_argument('-p', '--attach-package', type=str,
                       help='Specify package name to attach (without spawning)')
    
    parser.add_argument('-a', '--apps', action='store_true',
                       help='Show apps list for selection (original behavior)')
    
    parser.add_argument('--spawn', type=str,
                       help='Spawn mode with package name (same as -f)')
    
    parser.add_argument('--hook', type=str, 
                       help='Specify hook to run immediately after spawn (e.g., --hook traceRegisterNatives)')
    
    parser.add_argument('--hook-args', type=str,
                       help='Arguments for the hook function (comma-separated)')
    
    parser.add_argument('--preset', type=str,
                       help='Use predefined hook preset (jni_analysis, crypto_analysis, network_analysis, anti_debug)')
    
    parser.add_argument('--config', type=str,
                       help='Path to early hooks configuration file (default: early_hooks.json)')
    
    parser.add_argument('-o', '--output', type=str,
                       help='Redirect hook output to specified file (e.g., -o hooks.log)')
    
    parser.add_argument('--append', action='store_true',
                       help='Append to output file instead of overwriting (used with -o)')
    
    parser.add_argument('--version', action='version', 
                       version='fridac 1.0 (Frida {})'.format(get_frida_version()))
    
    args = parser.parse_args()
    
    # å†³å®šç›®æ ‡åŒ…å’Œè¿è¡Œæ¨¡å¼
    target_package = None
    spawn_mode = False
    force_show_apps = False
    early_hook = args.hook
    hook_args = args.hook_args
    preset = args.preset
    config_file = args.config
    output_file = args.output
    append_mode = args.append
    
    if args.package:  # -f com.example.appï¼ˆä»¥ Spawn æ¨¡å¼å¯åŠ¨å¹¶é™„åŠ ï¼‰
        target_package = args.package
        spawn_mode = True
    elif args.spawn:  # --spawn com.example.appï¼ˆSpawn æ¨¡å¼ï¼‰
        target_package = args.spawn
        spawn_mode = True
    elif args.attach_package:  # -p com.example.appï¼ˆç›´æ¥é™„åŠ åˆ°å·²è¿è¡Œåº”ç”¨ï¼‰
        target_package = args.attach_package
        spawn_mode = False
    elif args.apps:  # -aï¼ˆæ˜¾ç¤ºåº”ç”¨åˆ—è¡¨ï¼‰
        force_show_apps = True
    else:
        # é»˜è®¤è¡Œä¸ºï¼šå°è¯•é™„åŠ åˆ°å‰å°åº”ç”¨
        frontmost_id, frontmost_name = get_frontmost_app()
        if frontmost_id:
            target_package = frontmost_id
            spawn_mode = False
            log_success("æ£€æµ‹åˆ°å‰å°åº”ç”¨: {} ({})".format(frontmost_name, frontmost_id))
            log_info("å°†è‡ªåŠ¨è¿æ¥åˆ°æ­¤åº”ç”¨ï¼Œå¦‚éœ€é€‰æ‹©å…¶ä»–åº”ç”¨è¯·ä½¿ç”¨ 'fridac -a'")
        else:
            log_info("æ²¡æœ‰æ£€æµ‹åˆ°å‰å°åº”ç”¨ï¼Œæ˜¾ç¤ºåº”ç”¨åˆ—è¡¨...")
            force_show_apps = True
    
    # æ£€æµ‹å¹¶æ˜¾ç¤º Python ç¯å¢ƒä¿¡æ¯
    env_info = detect_python_environment()
    
    # æ˜¾ç¤º Banner ä¸ç¯å¢ƒä¿¡æ¯
    show_banner()
    show_environment_info(env_info)
    
    try:
        run_frida_session(spawn_mode=spawn_mode, target_package=target_package, force_show_apps=force_show_apps, 
                         early_hook=early_hook, hook_args=hook_args, preset=preset, config_file=config_file,
                         output_file=output_file, append_mode=append_mode)
    except KeyboardInterrupt:
        log_info("ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        log_exception(f"è¿è¡Œå‡ºé”™:{traceback.format_exc()}", )
        from fridac_core.logger import is_rich_available
        if not is_rich_available():
            log_warning("å»ºè®®å®‰è£… rich è·å¾—æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ: pip install rich")

if __name__ == '__main__':
    main()
