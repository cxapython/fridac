#!/usr/bin/env python3
"""
fridac - Enhanced Frida CLI tool with interactive JavaScript shell

Usage:
  fridac                              # Auto-attach to frontmost app (smart mode)
  fridac -a                           # Show apps list for selection
  fridac -f com.example.app           # Spawn app and attach (equivalent to: frida -U -f com.example.app)
  fridac -p com.example.app           # Attach to specific package (equivalent to: frida -U com.example.app)
  fridac --spawn com.example.app      # Spawn mode (same as -f)

Features:
- Interactive JavaScript shell with auto-completion
- Automatic device detection and connection
- Smart package name handling
- Built-in tracing and debugging functions

Automatically detects pyenv Python version and uses corresponding Frida:
- Python 3.6.8 -> Frida 14.x
- Python 3.8.2 -> Frida 16.x
"""

import sys
import os
import subprocess
import argparse
import signal
import readline  # For better command line editing
try:
    import rlcompleter
except ImportError:
    rlcompleter = None
import atexit
import frida
import threading
import queue
import time
from datetime import datetime

# Rich imports for beautiful UI
try:
    from rich.console import Console
    from rich.table import Table
    from rich.panel import Panel
    from rich.text import Text
    from rich.prompt import Prompt, Confirm
    from rich.progress import Progress, SpinnerColumn, TextColumn
    from rich.syntax import Syntax
    from rich.tree import Tree
    from rich.columns import Columns
    from rich.align import Align
    from rich.layout import Layout
    from rich.live import Live
    from rich.box import ROUNDED, DOUBLE, SIMPLE
    from rich.padding import Padding
    from rich import print as rprint
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    Console = None
    rprint = print

# History file for command history
HISTORY_FILE = os.path.expanduser("~/.fridac_history")

# Initialize Rich console
console = Console() if RICH_AVAILABLE else None

def log_info(message, **kwargs):
    """Enhanced info logging with rich formatting"""
    if RICH_AVAILABLE:
        timestamp = datetime.now().strftime("%H:%M:%S")
        console.print(f"[dim]{timestamp}[/dim] [cyan]â„¹ï¸[/cyan] {message}", **kwargs)
    else:
        print(f"â„¹ï¸  {message}")

def log_success(message, **kwargs):
    """Enhanced success logging with rich formatting"""
    if RICH_AVAILABLE:
        timestamp = datetime.now().strftime("%H:%M:%S")
        console.print(f"[dim]{timestamp}[/dim] [green]âœ…[/green] {message}", **kwargs)
    else:
        print(f"âœ… {message}")

def log_warning(message, **kwargs):
    """Enhanced warning logging with rich formatting"""
    if RICH_AVAILABLE:
        timestamp = datetime.now().strftime("%H:%M:%S")
        console.print(f"[dim]{timestamp}[/dim] [yellow]âš ï¸[/yellow] {message}", **kwargs)
    else:
        print(f"âš ï¸  {message}")

def log_error(message, **kwargs):
    """Enhanced error logging with rich formatting"""
    if RICH_AVAILABLE:
        timestamp = datetime.now().strftime("%H:%M:%S")
        console.print(f"[dim]{timestamp}[/dim] [red]âŒ[/red] {message}", **kwargs)
    else:
        print(f"âŒ {message}")

def log_debug(message, **kwargs):
    """Enhanced debug logging with rich formatting"""
    if RICH_AVAILABLE:
        timestamp = datetime.now().strftime("%H:%M:%S")
        console.print(f"[dim]{timestamp}[/dim] [magenta]ğŸ”[/magenta] {message}", **kwargs)
    else:
        print(f"ğŸ” {message}")

def show_banner():
    """Display beautiful fridac banner"""
    if RICH_AVAILABLE:
        banner_text = Text()
        banner_text.append("ğŸ”§ ", style="bold cyan")
        banner_text.append("fridac", style="bold green")
        banner_text.append(" - Enhanced Frida CLI Tool", style="bold white")
        
        panel = Panel(
            Align.center(banner_text),
            box=DOUBLE,
            border_style="cyan",
            padding=(1, 2)
        )
        console.print(panel)
    else:
        print("ğŸ”§ fridac - Enhanced Frida CLI Tool")

class FridacCompleter:
    """Enhanced auto-completion for fridac commands with rich display"""
    
    def __init__(self):
        # Available functions for completion with descriptions and examples
        self.functions = {
            # Java Hook å‡½æ•°
            'traceClass': ('ğŸ›ï¸  è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•', "traceClass('com.example.MainActivity')"),
            'hookAllMethodsInJavaClass': ('ğŸ›ï¸  è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•ï¼ˆæ–°å‡½æ•°åï¼‰', "hookAllMethodsInJavaClass('com.example.MainActivity')"),
            'traceMethod': ('ğŸ¯ è·Ÿè¸ªç‰¹å®šæ–¹æ³•', "traceMethod('com.example.Class.method', true)"),
            'hookJavaMethodWithTracing': ('ğŸ¯ è·Ÿè¸ªç‰¹å®šæ–¹æ³•ï¼ˆæ–°å‡½æ•°åï¼‰', "hookJavaMethodWithTracing('com.example.Class.method', true)"),
            'findClasses': ('ğŸ” æŸ¥æ‰¾åŒ¹é…çš„ç±»', "findClasses('MainActivity', true)"),
            'enumAllClasses': ('ğŸ“‹ æšä¸¾æ‰€æœ‰å·²åŠ è½½çš„ç±»', "enumAllClasses('com.example')"),
            'describeJavaClass': ('ğŸ“– æè¿°Javaç±»çš„è¯¦ç»†ä¿¡æ¯', "describeJavaClass('java.lang.String')"),
            'printStack': ('ğŸ“š æ‰“å°Javaè°ƒç”¨æ ˆ', "printStack()"),
            'findTragetClassLoader': ('ğŸ”— æŸ¥æ‰¾ç›®æ ‡ç±»åŠ è½½å™¨', "findTragetClassLoader('com.example.Class')"),
            'findTargetClassLoaderForClass': ('ğŸ”— æŸ¥æ‰¾ç›®æ ‡ç±»åŠ è½½å™¨ï¼ˆæ–°å‡½æ•°åï¼‰', "findTargetClassLoaderForClass('com.example.Class')"),
            'printJavaCallStack': ('ğŸ“š æ‰“å°Javaè°ƒç”¨æ ˆï¼ˆæ–°å‡½æ•°åï¼‰', "printJavaCallStack(true, 50)"),
            'findStrInMap': ('ğŸ—ºï¸ ç›‘æ§HashMapæŸ¥æ‰¾keyå¯¹åº”value', "findStrInMap('password', 1)"),
            
            # é«˜çº§è¿½è¸ªåŠŸèƒ½ï¼ˆåŸºäº r0tracerï¼‰
            'bypassTracerPidDetection': ('ğŸ”’ ç»•è¿‡TracerPidæ£€æµ‹', "bypassTracerPidDetection()"),
            'inspectObjectFields': ('ğŸ” æ£€æŸ¥å¯¹è±¡å­—æ®µè¯¦æƒ…', "inspectObjectFields(this, 'ä¸Šä¸‹æ–‡ä¿¡æ¯')"),
            'advancedMethodTracing': ('ğŸ¯ é«˜çº§æ–¹æ³•è¿½è¸ª', "advancedMethodTracing('com.example.Class.method', true, true)"),
            'batchHookWithFilters': ('ğŸ“¦ æ‰¹é‡Hookï¼ˆé»‘ç™½åå•ï¼‰', "batchHookWithFilters('com.example', 'test', null)"),
            'hookAllApplicationClasses': ('ğŸš€ Hookæ‰€æœ‰åº”ç”¨ç±»', "hookAllApplicationClasses(true)"),
            
            # ä»»åŠ¡ç®¡ç†ç³»ç»Ÿï¼ˆå‚è€ƒ objectionï¼‰
            'jobs': ('ğŸ“‹ æ˜¾ç¤ºæ‰€æœ‰æ´»è·ƒä»»åŠ¡', "jobs()"),
            'job': ('ğŸ” æ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…', "job(1)"),
            'kill': ('âŒ å–æ¶ˆæŒ‡å®šä»»åŠ¡', "kill(1)"),
            'killall': ('ğŸ§¹ å–æ¶ˆæ‰€æœ‰ä»»åŠ¡', "killall()"),
            'pause': ('â¸ï¸ æš‚åœä»»åŠ¡', "pause(1)"),
            'resume': ('â–¶ï¸ æ¢å¤ä»»åŠ¡', "resume(1)"),
            'jobstats': ('ğŸ“Š æ˜¾ç¤ºä»»åŠ¡ç»Ÿè®¡', "jobstats()"),
            'history': ('ğŸ“š æ˜¾ç¤ºä»»åŠ¡å†å²', "history(20)"),
            'cleanup': ('ğŸ§¹ æ¸…ç†å·²å®Œæˆä»»åŠ¡', "cleanup()"),
            'jobhelp': ('â“ ä»»åŠ¡ç®¡ç†å¸®åŠ©', "jobhelp()"),
            
            # å¸¦ä»»åŠ¡ç®¡ç†çš„Hookå‡½æ•°
            'traceMethodWithJob': ('ğŸ¯ å¸¦ä»»åŠ¡ç®¡ç†çš„æ–¹æ³•Hook', "traceMethodWithJob('com.example.Class.method', true)"),
            'traceClassWithJob': ('ğŸ›ï¸ å¸¦ä»»åŠ¡ç®¡ç†çš„ç±»Hook', "traceClassWithJob('com.example.MainActivity')"),
            'advancedMethodTracingWithJob': ('ğŸ”¥ å¸¦ä»»åŠ¡ç®¡ç†çš„é«˜çº§è¿½è¸ª', "advancedMethodTracingWithJob('method', true, true)"),
            'batchHookWithJob': ('ğŸ“¦ å¸¦ä»»åŠ¡ç®¡ç†çš„æ‰¹é‡Hook', "batchHookWithJob('com.example', 'test', null)"),
            
            # å®šä½Hookå‡½æ•°
            'hookBase64': ('ğŸ” Hook Base64ç¼–ç è§£ç ', "hookBase64(1)"),
            'hookToast': ('ğŸ Hook Toastæ˜¾ç¤º', "hookToast(1)"),
            'hookJSONObject': ('ğŸ“ Hook JSONObjectæ“ä½œ', "hookJSONObject(1)"),
            'hookHashMap': ('ğŸ—ºï¸ Hook HashMapæ“ä½œ', "hookHashMap('key', 1)"),
            'hookEditText': ('ğŸ“ Hook EditTextè¾“å…¥', "hookEditText(1)"),
            'hookArrayList': ('ğŸ“‹ Hook ArrayListæ“ä½œ', "hookArrayList(1)"),
            'hookLoadLibrary': ('ğŸ“š Hook åŠ¨æ€åº“åŠ è½½', "hookLoadLibrary(1)"),
            'hookNewStringUTF': ('ğŸ”¤ Hook JNIå­—ç¬¦ä¸²åˆ›å»º', "hookNewStringUTF(1)"),
            'hookFileOperations': ('ğŸ“ Hook æ–‡ä»¶æ“ä½œ', "hookFileOperations(1)"),
            'hookLog': ('ğŸ“œ Hook Logè¾“å‡º', "hookLog(1)"),
            'hookURL': ('ğŸŒ Hook URLè¯·æ±‚', "hookURL(1)"),
            'enableAllHooks': ('ğŸš€ å¯ç”¨æ‰€æœ‰å®šä½Hook', "enableAllHooks(1)"),
            
            # Native Hook å‡½æ•°
            'nativeHookNativeFunction': ('ğŸ”§ Hook Native å‡½æ•°', "nativeHookNativeFunction('malloc', {argTypes: ['int']})"),
            'nativeFindModules': ('ğŸ“¦ æŸ¥æ‰¾åŠ è½½çš„æ¨¡å—', "nativeFindModules(/libc/)"),
            'nativeFindExports': ('ğŸ“¤ æŸ¥æ‰¾æ¨¡å—å¯¼å‡ºå‡½æ•°', "nativeFindExports('libc.so', /malloc/)"),
            'nativeFindImports': ('ğŸ“¥ æŸ¥æ‰¾æ¨¡å—å¯¼å…¥å‡½æ•°', "nativeFindImports('app', /strcpy/)"),
            'nativeSearchMemory': ('ğŸ” æœç´¢å†…å­˜æ¨¡å¼', "nativeSearchMemory('48 89 e5')"),
            'printNativeStack': ('ğŸ“š æ‰“å°Nativeè°ƒç”¨æ ˆ', "printNativeStack()"),
            
            # é«˜çº§Native Hook
            'nativeHookDlopenFamily': ('ğŸ“š HookåŠ¨æ€åº“åŠ è½½', "nativeHookDlopenFamily(1)"),
            'nativeHookJNIFunctions': ('â˜• Hook JNIå‡½æ•°', "nativeHookJNIFunctions(1)"),
            'nativeHookCryptoFunctions': ('ğŸ” HookåŠ å¯†ç®—æ³•', "nativeHookCryptoFunctions('aes', 1)"),
            'nativeHookNetworkFunctions': ('ğŸŒ Hookç½‘ç»œå‡½æ•°', "nativeHookNetworkFunctions(1)"),
            'nativeHookAntiDebug': ('ğŸ›¡ï¸ Hookåè°ƒè¯•æ£€æµ‹', "nativeHookAntiDebug(1)"),
            'nativeAnalyzeSO': ('ğŸ” åˆ†æSOæ–‡ä»¶', "nativeAnalyzeSO('libtest.so', 1, 1)"),
            'nativeEnableAllHooks': ('ğŸš€ å¯ç”¨æ‰€æœ‰Native Hook', "nativeEnableAllHooks(1)"),
            'nativeQuickHookCrypto': ('âš¡ å¿«é€ŸHookåŠ å¯†', "nativeQuickHookCrypto('md5')"),
            'nativeQuickHookNetwork': ('âš¡ å¿«é€ŸHookç½‘ç»œ', "nativeQuickHookNetwork()"),
            'nativeQuickAnalyzeApp': ('âš¡ å¿«é€Ÿåˆ†æåº”ç”¨', "nativeQuickAnalyzeApp()"),
            
            # æ™ºèƒ½å·¥å…·
            'smartTrace': ('ğŸ¯ æ™ºèƒ½è¯†åˆ«å¹¶Hookç›®æ ‡', "smartTrace('com.example.MainActivity')"),
            'intelligentHookDispatcher': ('ğŸ¯ æ™ºèƒ½è¯†åˆ«å¹¶Hookç›®æ ‡ï¼ˆæ–°å‡½æ•°åï¼‰', "intelligentHookDispatcher('com.example.MainActivity', {enableStackTrace: true})"),
            'loadNativeSupport': ('ğŸ”§ åŠ è½½Native Hookå·¥å…·', "loadNativeSupport()"),
            
            # å·¥å…·å‡½æ•°
            'uniqBy': ('ğŸ² æ•°ç»„å»é‡å·¥å…·', "uniqBy(array, function(item) { return item.id; })"),
            'bytesToString': ('ğŸ”¤ å­—èŠ‚è½¬æ¢ä¸ºå­—ç¬¦ä¸²', "bytesToString([72, 101, 108, 108, 111])"),
            'LOG': ('ğŸ“ å¢å¼ºçš„æ—¥å¿—è¾“å‡º', "LOG('message', {c: Color.Green})"),
            'Color': ('ğŸ¨ é¢œè‰²å¸¸é‡', "Color.Red, Color.Green, Color.Blue"),
            'help': ('â“ æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯', "help()"),
            'q': ('ğŸšª é€€å‡ºç¨‹åº', "q"),
            'quit': ('ğŸšª é€€å‡ºç¨‹åº', "quit"),
            'exit': ('ğŸšª é€€å‡ºç¨‹åº', "exit")
        }
        
        # Common Java class patterns for suggestions with categories
        self.common_patterns = {
            'Androidç³»ç»Ÿç±»': [
                'com.android.', 'android.app.', 'android.content.',
                'android.view.', 'android.widget.', 'android.os.',
                'android.util.', 'android.net.'
            ],
            'å¸¸è§åº”ç”¨åŒ…å': [
                'com.google.', 'com.facebook.', 'com.tencent.',
                'com.alibaba.', 'com.baidu.', 'com.sina.', 'com.xiaomi.',
                'com.huawei.', 'com.oppo.', 'com.vivo.'
            ],
            'Javaæ ‡å‡†åº“': [
                'java.lang.', 'java.util.', 'java.io.',
                'java.net.', 'java.security.', 'java.text.'
            ],
            'Androidç»„ä»¶': [
                'MainActivity', 'Application', 'Activity', 'Service', 
                'Fragment', 'BroadcastReceiver', 'ContentProvider'
            ]
        }
    
    def show_completion_help(self):
        """Display beautiful completion help using rich"""
        if not RICH_AVAILABLE:
            return
            
        # Create detailed function table with descriptions and examples
        func_table = Table(title="ğŸš€ å¯ç”¨å‡½æ•°", box=ROUNDED, show_header=True, header_style="bold magenta")
        func_table.add_column("æè¿°", style="green", width=40)
        func_table.add_column("ä½¿ç”¨ç¤ºä¾‹", style="yellow", width=55)
        
        # Select key functions to display (avoid overwhelming the user)
        key_functions = [
            ('traceClass', 'ğŸ›ï¸ è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•', "traceClass('com.example.MainActivity')"),
            ('hookAllMethodsInJavaClass', 'ğŸ›ï¸ è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•ï¼ˆæ–°å‡½æ•°åï¼‰', "hookAllMethodsInJavaClass('com.example.MainActivity')"),
            ('traceMethod', 'ğŸ¯ è·Ÿè¸ªç‰¹å®šæ–¹æ³•', "traceMethod('com.example.Class.method', true)"),
            ('hookJavaMethodWithTracing', 'ğŸ¯ è·Ÿè¸ªç‰¹å®šæ–¹æ³•ï¼ˆæ–°å‡½æ•°åï¼‰', "hookJavaMethodWithTracing('com.example.Class.method', true)"),
            ('findClasses', 'ğŸ” æŸ¥æ‰¾åŒ¹é…çš„ç±»', "findClasses('MainActivity', true)"),
            ('enumAllClasses', 'ğŸ“‹ æšä¸¾æ‰€æœ‰å·²åŠ è½½çš„ç±»', "enumAllClasses('com.example')"),
            ('describeJavaClass', 'ğŸ“– æè¿°Javaç±»çš„è¯¦ç»†ä¿¡æ¯', "describeJavaClass('java.lang.String')"),
            ('printStack', 'ğŸ“š æ‰“å°Javaè°ƒç”¨æ ˆ', "printStack()"),
            ('findTargetClassLoaderForClass', 'ğŸ”— æŸ¥æ‰¾ç›®æ ‡ç±»åŠ è½½å™¨ï¼ˆæ–°å‡½æ•°åï¼‰', "findTargetClassLoaderForClass('com.example.Class')"),
            ('printJavaCallStack', 'ğŸ“š æ‰“å°Javaè°ƒç”¨æ ˆï¼ˆæ–°å‡½æ•°åï¼‰', "printJavaCallStack(true, 50)"),
            ('findStrInMap', 'ğŸ—ºï¸ ç›‘æ§HashMapæŸ¥æ‰¾keyå¯¹åº”value', "findStrInMap('password', 1)"),
            ('bypassTracerPidDetection', 'ğŸ”’ ç»•è¿‡TracerPidæ£€æµ‹', "bypassTracerPidDetection()"),
            ('inspectObjectFields', 'ğŸ” æ£€æŸ¥å¯¹è±¡å­—æ®µè¯¦æƒ…', "inspectObjectFields(this, 'ä¸Šä¸‹æ–‡ä¿¡æ¯')"),
            ('advancedMethodTracing', 'ğŸ¯ é«˜çº§æ–¹æ³•è¿½è¸ª', "advancedMethodTracing('com.example.Class.method', true, true)"),
            ('batchHookWithFilters', 'ğŸ“¦ æ‰¹é‡Hookï¼ˆé»‘ç™½åå•ï¼‰', "batchHookWithFilters('com.example', 'test', null)"),
            ('hookAllApplicationClasses', 'ğŸš€ Hookæ‰€æœ‰åº”ç”¨ç±»', "hookAllApplicationClasses(true)"),
            ('jobs', 'ğŸ“‹ æ˜¾ç¤ºæ‰€æœ‰æ´»è·ƒä»»åŠ¡', "jobs()"),
            ('job', 'ğŸ” æ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…', "job(1)"),
            ('kill', 'âŒ å–æ¶ˆæŒ‡å®šä»»åŠ¡', "kill(1)"),
            ('killall', 'ğŸ§¹ å–æ¶ˆæ‰€æœ‰ä»»åŠ¡', "killall()"),
            ('jobstats', 'ğŸ“Š æ˜¾ç¤ºä»»åŠ¡ç»Ÿè®¡', "jobstats()"),
            ('traceMethodWithJob', 'ğŸ¯ å¸¦ä»»åŠ¡ç®¡ç†çš„æ–¹æ³•Hook', "traceMethodWithJob('com.example.Class.method', true)"),
            ('hookBase64', 'ğŸ” Hook Base64ç¼–ç è§£ç ', "hookBase64(1)"),
            ('hookToast', 'ğŸ Hook Toastæ˜¾ç¤º', "hookToast(1)"),
            ('hookJSONObject', 'ğŸ“ Hook JSONObjectæ“ä½œ', "hookJSONObject(1)"),
            ('hookHashMap', 'ğŸ—ºï¸ Hook HashMapæ“ä½œ', "hookHashMap('key', 1)"),
            ('enableAllHooks', 'ğŸš€ å¯ç”¨æ‰€æœ‰å®šä½Hook', "enableAllHooks(1)"),
            ('nativeHookCryptoFunctions', 'ğŸ” HookåŠ å¯†ç®—æ³•', "nativeHookCryptoFunctions('aes', 1)"),
            ('nativeAnalyzeSO', 'ğŸ” åˆ†æSOæ–‡ä»¶', "nativeAnalyzeSO('libtest.so', 1, 1)"),
            ('smartTrace', 'ğŸ¯ æ™ºèƒ½è¯†åˆ«å¹¶Hookç›®æ ‡', "smartTrace('com.example.MainActivity')"),
            ('intelligentHookDispatcher', 'ğŸ¯ æ™ºèƒ½è¯†åˆ«å¹¶Hookç›®æ ‡ï¼ˆæ–°å‡½æ•°åï¼‰', "intelligentHookDispatcher('com.example.MainActivity', {enableStackTrace: true})"),
            ('help', 'â“ æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯', "help()"),
        ]
        
        for func_name, description, example in key_functions:
            # Highlight function name in example
            highlighted_example = example.replace(func_name, f"[cyan]{func_name}[/cyan]")
            func_table.add_row(description, highlighted_example)
        
        # Create patterns tree
        patterns_tree = Tree("ğŸ“ [bold blue]å¸¸ç”¨ç±»åæ¨¡å¼[/bold blue]")
        for category, patterns in self.common_patterns.items():
            category_branch = patterns_tree.add(f"[yellow]{category}[/yellow]")
            for pattern in patterns[:3]:  # Show first 3 in each category
                category_branch.add(f"[dim]{pattern}...[/dim]")
        
        # Display function table and patterns
        console.print()
        console.print(func_table)
        console.print("ğŸ’¡ [bold blue]è¿æ¥åº”ç”¨åä½¿ç”¨ help() æŸ¥çœ‹æ‰€æœ‰å‡½æ•°çš„è¯¦ç»†è¯´æ˜[/bold blue]")
        console.print()
    
    def complete(self, text, state):
        """Enhanced completion with rich pattern matching"""
        if state == 0:
            # First time this text is completed
            self.matches = []
            
            if text:
                # Match function names
                for func in self.functions.keys():
                    if func.startswith(text):
                        self.matches.append(f"{func}(")
                
                # If inside quotes, suggest common patterns
                if '"' in readline.get_line_buffer() or "'" in readline.get_line_buffer():
                    for category, patterns in self.common_patterns.items():
                        for pattern in patterns:
                            if pattern.startswith(text):
                                self.matches.append(pattern)
            else:
                # No text yet, show all functions
                self.matches = [f"{func}(" for func in self.functions.keys()]
        
        # Return the next match
        if state < len(self.matches):
            return self.matches[state]
        else:
            return None

def setup_history():
    """Setup command history and auto-completion"""
    try:
        readline.read_history_file(HISTORY_FILE)
        readline.set_history_length(1000)
    except FileNotFoundError:
        pass
    
    # Setup auto-completion
    completer = FridacCompleter()
    readline.set_completer(completer.complete)
    
    # Enable tab completion
    if rlcompleter:
        readline.parse_and_bind("tab: complete")
    
    # Set completion delimiters (don't break on these characters)
    readline.set_completer_delims(' \t\n`!@#$%^&*()=+[{]}\\|;:,<>?')
    
    def save_history():
        try:
            readline.write_history_file(HISTORY_FILE)
        except:
            pass
    
    atexit.register(save_history)

def detect_python_environment():
    """Detect current Python environment and corresponding Frida version"""
    python_info = {
        'version': 'unknown',
        'executable': sys.executable,
        'frida_version': 'unknown',
        'using_pyenv': False
    }
    
    try:
        # Get Python version
        python_version = "{}.{}.{}".format(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)
        python_info['version'] = python_version
        
        # Check if pyenv is available and active
        pyenv_available = False
        try:
            pyenv_result = subprocess.run(['pyenv', 'version'], 
                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                        universal_newlines=True)
            if pyenv_result.returncode == 0:
                pyenv_version = pyenv_result.stdout.split()[0]
                python_info['pyenv_version'] = pyenv_version
                python_info['using_pyenv'] = True
                pyenv_available = True
        except FileNotFoundError:
            # pyenv not found, use system python3
            pass
        except:
            pass
        
        # Determine which Python to use for Frida
        python_executable = sys.executable
        if not pyenv_available:
            # Try to use python3 if available and current is not python3
            try:
                # Check if python3 is available
                python3_result = subprocess.run(['python3', '--version'], 
                                              stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                              universal_newlines=True)
                if python3_result.returncode == 0:
                    # Use python3 as preferred executable
                    python_executable = 'python3'
                    python_info['executable'] = python_executable
                    # Update version info from python3
                    version_output = python3_result.stdout.strip()
                    if 'Python' in version_output:
                        version_parts = version_output.split()[1].split('.')
                        if len(version_parts) >= 3:
                            python_info['version'] = "{}.{}.{}".format(version_parts[0], version_parts[1], version_parts[2])
            except:
                # Fallback to current executable
                pass
        
        # Get Frida version using the determined executable
        frida_commands = [
            [python_executable, '-m', 'frida', '--version'],
            [python_executable, '-m', 'frida_tools.frida', '--version'],
            ['frida', '--version']  # System frida as fallback
        ]
        
        for cmd in frida_commands:
            try:
                result = subprocess.run(cmd, 
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
                                      universal_newlines=True, timeout=5)
                if result.returncode == 0:
                    python_info['frida_version'] = result.stdout.strip()
                    break
            except:
                continue
            
    except Exception as e:
        log_warning("æ£€æµ‹Pythonç¯å¢ƒæ—¶å‡ºé”™: {}".format(e))
    
    return python_info

def get_frida_version():
    """Get current Frida version"""
    try:
        # Use environment detection to get the correct Python executable
        env_info = detect_python_environment()
        return env_info.get('frida_version', 'unknown')
    except:
        return "unknown"

def get_frontmost_app():
    """Get the frontmost (current foreground) application"""
    try:
        device = frida.get_usb_device()
        frontmost_app = device.get_frontmost_application()
        if frontmost_app and frontmost_app.identifier:
            return frontmost_app.identifier, frontmost_app.name
        return None, None
    except Exception as e:
        log_error("è·å–å‰å°åº”ç”¨å¤±è´¥: {}".format(e))
        return None, None

def find_target_app():
    """Find the target application automatically"""
    try:
        # Detect environment to get the correct Python executable
        env_info = detect_python_environment()
        python_executable = env_info.get('executable', sys.executable)
        
        # Get list of running apps using determined Python executable
        frida_ps_commands = [
            [python_executable, '-m', 'frida_tools.ps', '-Ua'],
            [python_executable, '-m', 'frida_tools.frida_ps', '-Ua'],
            ['frida-ps', '-Ua']  # System frida-ps as fallback
        ]
        
        result = None
        for cmd in frida_ps_commands:
            try:
                result = subprocess.run(cmd, 
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                      universal_newlines=True, timeout=10)
                if result.returncode == 0:
                    break
            except:
                continue
        
        if not result or result.returncode != 0:
            log_error("æ— æ³•è·å–åº”ç”¨åˆ—è¡¨ï¼Œè¯·æ£€æŸ¥ Frida å®‰è£…")
            return None
        
        lines = result.stdout.strip().split('\n')[1:]  # Skip header
        
        if not lines:
            log_error("æ²¡æœ‰æ‰¾åˆ°è¿è¡Œçš„åº”ç”¨ç¨‹åº")
            return None
        
        # Parse apps data
        apps = []
        for line in lines:
            line = line.strip()
            if not line:  # Skip empty lines
                continue
            # frida-ps -Ua output: PID, Name, Identifier
            # Split into at most 3 parts to handle spaces in names
            parts = line.split(None, 2)
            if len(parts) >= 3:
                pid = parts[0]
                name = parts[1]
                identifier = parts[2]
                # Validate PID is numeric
                if pid.isdigit():
                    apps.append((pid, name, identifier))
        
        if not apps:
            log_error("æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„åº”ç”¨ç¨‹åº")
            return None
        
        # Show available apps with rich table
        if RICH_AVAILABLE:
            app_table = Table(title="ğŸ“± å¯ç”¨çš„åº”ç”¨ç¨‹åº", box=ROUNDED, show_header=True, header_style="bold cyan")
            app_table.add_column("åºå·", style="magenta", width=6, justify="center")
            app_table.add_column("åº”ç”¨åç§°", style="green", min_width=15)
            app_table.add_column("åŒ…å", style="blue", min_width=20)
            app_table.add_column("PID", style="yellow", width=8, justify="center")
            
            for i, (pid, name, identifier) in enumerate(apps, 1):
                app_table.add_row(str(i), name, identifier, pid)
            
            console.print()
            console.print(app_table)
            console.print()
        else:
            log_info("å¯ç”¨çš„åº”ç”¨ç¨‹åº:")
            for i, (pid, name, identifier) in enumerate(apps, 1):
                print("  [{}] {} {} (PID: {})".format(i, name, identifier, pid))
            
        # Auto-select if only one app, otherwise ask user
        if len(apps) == 1:
            selected_app = apps[0]
            log_success("è‡ªåŠ¨é€‰æ‹©: {} {}".format(selected_app[1], selected_app[2]))
            return selected_app[2]  # Return identifier (package name)
        else:
            while True:
                try:
                    if RICH_AVAILABLE:
                        choice = Prompt.ask(
                            "\n[bold cyan]è¯·é€‰æ‹©åº”ç”¨ç¨‹åº[/bold cyan]",
                            choices=[str(i) for i in range(1, len(apps) + 1)] + ['q', 'quit', 'exit'],
                            default='q',
                            show_choices=False
                        ).strip()
                        console.print(f"[dim]è¾“å…¥: {choice}[/dim]")
                    else:
                        choice = input("\nè¯·é€‰æ‹©åº”ç”¨ç¨‹åº (è¾“å…¥åºå·æˆ– 'q' é€€å‡º): ").strip()
                    
                    # Check for quit command
                    if choice.lower() in ['q', 'quit', 'exit']:
                        log_info("é€€å‡ºé€‰æ‹©")
                        return None
                    
                    if choice.isdigit():
                        idx = int(choice) - 1
                        if 0 <= idx < len(apps):
                            selected_app = apps[idx]
                            log_success("é€‰æ‹©äº†: {} {}".format(selected_app[1], selected_app[2]))
                            return selected_app[2]  # Return identifier (package name)
                    
                    log_warning("æ— æ•ˆçš„é€‰æ‹©ï¼Œè¯·é‡æ–°è¾“å…¥ (1-{} æˆ– q)".format(len(apps)))
                except KeyboardInterrupt:
                    log_info("æ“ä½œå–æ¶ˆ")
                    return None
                    
    except Exception as e:
        log_error("è·å–åº”ç”¨ç¨‹åºåˆ—è¡¨å¤±è´¥: {}".format(e))
        return None

def create_frida_script():
    """Create the Frida script with all our functions"""
    # Try to find frida_common.js in multiple locations
    possible_paths = [
        os.path.join(os.path.dirname(os.path.abspath(__file__)), 'frida_common.js'),
        os.path.join(os.path.expanduser('~'), 'fridaproject', 'frida_common.js'),
        'frida_common.js',  # Absolute fallback
        './frida_common.js'  # Current directory
    ]
    
    script_path = None
    for path in possible_paths:
        if os.path.exists(path):
            script_path = path
            break
    
    if not script_path:
        log_error("æ‰¾ä¸åˆ° frida_common.js æ–‡ä»¶ï¼Œå·²å°è¯•è·¯å¾„:")
        for path in possible_paths:
            log_debug("   - {}".format(path))
        return None
        
    with open(script_path, 'r', encoding='utf-8') as f:
        js_content = f.read()
    
    # Try to load Native Hook tools as well
    native_paths = [
        os.path.join(os.path.dirname(os.path.abspath(__file__)), 'frida_native_common.js'),
        os.path.join(os.path.expanduser('~'), 'fridaproject', 'frida_native_common.js'),
        'frida_native_common.js',
        './frida_native_common.js'
    ]
    
    native_script_path = None
    for path in native_paths:
        if os.path.exists(path):
            native_script_path = path
            break
    
    if native_script_path:
        log_debug("æ‰¾åˆ° Native Hook å·¥å…·: {}".format(native_script_path))
        try:
            with open(native_script_path, 'r', encoding='utf-8') as f:
                native_content = f.read()
            js_content += '\n\n// ===== Native Hook Tools =====\n'
            js_content += native_content
            log_debug("Native Hook å·¥å…·å·²é›†æˆ")
        except Exception as e:
            log_warning("åŠ è½½ Native Hook å·¥å…·å¤±è´¥: {}".format(e))
    else:
        log_debug("æœªæ‰¾åˆ° frida_native_common.jsï¼Œä»…åŠ è½½ Java Hook å·¥å…·")
    
    # Try to load Location Hook tools as well
    location_paths = [
        os.path.join(os.path.dirname(os.path.abspath(__file__)), 'frida_location_hooks.js'),
        os.path.join(os.path.expanduser('~'), 'fridaproject', 'frida_location_hooks.js'),
        'frida_location_hooks.js',
        './frida_location_hooks.js'
    ]
    
    location_script_path = None
    for path in location_paths:
        if os.path.exists(path):
            location_script_path = path
            break
    
    if location_script_path:
        log_debug("æ‰¾åˆ°å®šä½Hookå·¥å…·: {}".format(location_script_path))
        try:
            with open(location_script_path, 'r', encoding='utf-8') as f:
                location_content = f.read()
            js_content += '\n\n// ===== Location Hook Tools =====\n'
            js_content += location_content
            log_debug("å®šä½Hookå·¥å…·å·²é›†æˆ")
        except Exception as e:
            log_warning("åŠ è½½å®šä½Hookå·¥å…·å¤±è´¥: {}".format(e))
    else:
        log_debug("æœªæ‰¾åˆ° frida_location_hooks.jsï¼Œå®šä½å·¥å…·ä¸å¯ç”¨")
    
    # é›†æˆé«˜çº§è¿½è¸ªåŠŸèƒ½
    advanced_tracer_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'frida_advanced_tracer.js')
    if os.path.exists(advanced_tracer_path):
        try:
            with open(advanced_tracer_path, 'r', encoding='utf-8') as f:
                advanced_content = f.read()
            js_content += '\n\n// ===== Advanced Tracer Tools (Based on r0tracer) =====\n'
            js_content += advanced_content
            log_debug("é«˜çº§è¿½è¸ªå·¥å…·å·²é›†æˆï¼ˆåŸºäº r0tracerï¼‰")
        except Exception as e:
            log_warning("åŠ è½½é«˜çº§è¿½è¸ªå·¥å…·å¤±è´¥: {}".format(e))
    else:
        log_debug("æœªæ‰¾åˆ° frida_advanced_tracer.jsï¼Œé«˜çº§è¿½è¸ªå·¥å…·ä¸å¯ç”¨")
    
    # é›†æˆä»»åŠ¡ç®¡ç†ç³»ç»Ÿ
    job_manager_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'frida_job_manager.js')
    if os.path.exists(job_manager_path):
        try:
            with open(job_manager_path, 'r', encoding='utf-8') as f:
                job_manager_content = f.read()
            js_content += '\n\n// ===== Hook Job Management System =====\n'
            js_content += job_manager_content
            log_debug("ä»»åŠ¡ç®¡ç†ç³»ç»Ÿå·²é›†æˆ")
        except Exception as e:
            log_warning("åŠ è½½ä»»åŠ¡ç®¡ç†ç³»ç»Ÿå¤±è´¥: {}".format(e))
    else:
        log_debug("æœªæ‰¾åˆ° frida_job_manager.jsï¼Œä»»åŠ¡ç®¡ç†ä¸å¯ç”¨")
    
    # é›†æˆä»»åŠ¡ç®¡ç†å‘½ä»¤
    job_commands_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'frida_job_commands.js')
    if os.path.exists(job_commands_path):
        try:
            with open(job_commands_path, 'r', encoding='utf-8') as f:
                job_commands_content = f.read()
            js_content += '\n\n// ===== Job Management Commands =====\n'
            js_content += job_commands_content
            log_debug("ä»»åŠ¡ç®¡ç†å‘½ä»¤å·²é›†æˆ")
        except Exception as e:
            log_warning("åŠ è½½ä»»åŠ¡ç®¡ç†å‘½ä»¤å¤±è´¥: {}".format(e))
    else:
        log_debug("æœªæ‰¾åˆ° frida_job_commands.jsï¼Œä»»åŠ¡ç®¡ç†å‘½ä»¤ä¸å¯ç”¨")
    
    # Add interactive shell initialization and Java.perform wrapper
    js_content = '''
Java.perform(function() {
''' + js_content + '''

// Interactive shell functions
function help() {
    LOG("\\nğŸ“š fridac - å®Œæ•´å‡½æ•°å‚è€ƒæ‰‹å†Œ", { c: Color.Cyan });
    LOG("=" + "=".repeat(80), { c: Color.Gray });
    
    LOG("\\nâ˜• Java Hook å‡½æ•°:", { c: Color.Green });
    LOG("  ğŸ“‹ ç±»è¿½è¸ª:", { c: Color.Blue });
    LOG("    traceClass(className) - è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•", { c: Color.White });
    LOG("    hookAllMethodsInJavaClass(className) - è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•ï¼ˆæ–°å‡½æ•°åï¼‰", { c: Color.White });
    LOG("      ç¤ºä¾‹: traceClass('com.example.MainActivity')", { c: Color.Yellow });
    
    LOG("  ğŸ¯ æ–¹æ³•è¿½è¸ª:", { c: Color.Blue });
    LOG("    traceMethod(classMethod, showTrace, returnValue) - è·Ÿè¸ªç‰¹å®šæ–¹æ³•", { c: Color.White });
    LOG("    hookJavaMethodWithTracing(methodName, enableStackTrace, customReturnValue) - è·Ÿè¸ªç‰¹å®šæ–¹æ³•ï¼ˆæ–°å‡½æ•°åï¼‰", { c: Color.White });
    LOG("      ç¤ºä¾‹: traceMethod('com.example.MainActivity.onCreate', true)", { c: Color.Yellow });
    
    LOG("  ğŸ” ç±»æŸ¥æ‰¾:", { c: Color.Blue });
    LOG("    findClasses(pattern, showMethods) - æŸ¥æ‰¾ç±»", { c: Color.White });
    LOG("    enumAllClasses(pattern) - æšä¸¾æ‰€æœ‰ç±»", { c: Color.White });
    LOG("    describeJavaClass(className) - æè¿°Javaç±»è¯¦ç»†ä¿¡æ¯", { c: Color.White });
    LOG("      ç¤ºä¾‹: findClasses('MainActivity', true)", { c: Color.Yellow });
    
    LOG("  ğŸ—ºï¸ å¯¹è±¡ç›‘æ§:", { c: Color.Blue });
    LOG("    findStrInMap(key, showStack) - ç›‘æ§HashMapæŸ¥æ‰¾keyå¯¹åº”value", { c: Color.White });
    LOG("      ç¤ºä¾‹: findStrInMap('password', 1)  // 1=æ˜¾ç¤ºè°ƒç”¨æ ˆ, 0=ä¸æ˜¾ç¤º", { c: Color.Yellow });
    
    if (typeof hookBase64 !== 'undefined') {
        LOG("\\nğŸ“ å®šä½Hookå‡½æ•°:", { c: Color.Green });
        LOG("  ğŸ” ç¼–ç è§£ç :", { c: Color.Blue });
        LOG("    hookBase64(showStack) - Hook Base64ç¼–ç è§£ç ", { c: Color.White });
        
        LOG("  ğŸ“± ç•Œé¢ç»„ä»¶:", { c: Color.Blue });
        LOG("    hookToast(showStack) - Hook Toastæ˜¾ç¤º", { c: Color.White });
        LOG("    hookEditText(showStack) - Hook EditTextè¾“å…¥", { c: Color.White });
        
        LOG("  ğŸ“Š æ•°æ®ç»“æ„:", { c: Color.Blue });
        LOG("    hookJSONObject(showStack) - Hook JSONObjectæ“ä½œ", { c: Color.White });
        LOG("    hookHashMap(key, showStack) - Hook HashMapæ“ä½œ", { c: Color.White });
        LOG("    hookArrayList(showStack) - Hook ArrayListæ“ä½œ", { c: Color.White });
        
        LOG("  ğŸ“š ç³»ç»ŸåŠŸèƒ½:", { c: Color.Blue });
        LOG("    hookLoadLibrary(showStack) - Hook åŠ¨æ€åº“åŠ è½½", { c: Color.White });
        LOG("    hookNewStringUTF(showStack) - Hook JNIå­—ç¬¦ä¸²åˆ›å»º", { c: Color.White });
        LOG("    hookFileOperations(showStack) - Hook æ–‡ä»¶æ“ä½œ", { c: Color.White });
        LOG("    hookLog(showStack) - Hook Logè¾“å‡º", { c: Color.White });
        LOG("    hookURL(showStack) - Hook URLè¯·æ±‚", { c: Color.White });
        
        LOG("  ğŸš€ æ‰¹é‡æ“ä½œ:", { c: Color.Blue });
        LOG("    enableAllHooks(showStack) - ä¸€é”®å¯ç”¨æ‰€æœ‰å®šä½Hook", { c: Color.White });
        LOG("      ç¤ºä¾‹: enableAllHooks(1)  // å¯ç”¨æ‰€æœ‰Hookå¹¶æ˜¾ç¤ºè°ƒç”¨æ ˆ", { c: Color.Yellow });
    } else {
        LOG("\\nğŸ“ å®šä½Hookå·¥å…·: æœªåŠ è½½", { c: Color.Yellow });
        LOG("  éœ€è¦ frida_location_hooks.js æ–‡ä»¶", { c: Color.Gray });
    }
    
    if (typeof nativeHookNativeFunction !== 'undefined') {
        LOG("\\nğŸ”§ Native Hook å‡½æ•°:", { c: Color.Green });
        LOG("  ğŸ” åŸºç¡€å·¥å…·:", { c: Color.Blue });
        LOG("    nativeHookNativeFunction(address, options) - Hook Native å‡½æ•°", { c: Color.White });
        LOG("    nativeFindModules(pattern) - æŸ¥æ‰¾æ¨¡å—", { c: Color.White });
        LOG("    nativeFindExports(module, pattern) - æŸ¥æ‰¾å¯¼å‡ºå‡½æ•°", { c: Color.White });
        LOG("    nativeSearchMemory(pattern) - æœç´¢å†…å­˜", { c: Color.White });
        LOG("    printNativeStack() - æ‰“å°Nativeè°ƒç”¨æ ˆ", { c: Color.White });
        
        if (typeof nativeHookDlopenFamily !== 'undefined') {
            LOG("  ğŸš€ é«˜çº§Hook:", { c: Color.Blue });
            LOG("    nativeHookDlopenFamily(showStack) - HookåŠ¨æ€åº“åŠ è½½", { c: Color.White });
            LOG("    nativeHookJNIFunctions(showStack) - Hook JNIå‡½æ•°", { c: Color.White });
            LOG("    nativeHookAntiDebug(showStack) - Hookåè°ƒè¯•æ£€æµ‹", { c: Color.White });
            
            LOG("  ğŸ” åŠ å¯†Hook:", { c: Color.Blue });
            LOG("    nativeHookCryptoFunctions(algorithm, showStack) - HookåŠ å¯†ç®—æ³•", { c: Color.White });
            LOG("      æ”¯æŒç®—æ³•: aes, des, md5, sha, all", { c: Color.Yellow });
            
            LOG("  ğŸŒ ç½‘ç»œHook:", { c: Color.Blue });
            LOG("    nativeHookNetworkFunctions(showStack) - Hookç½‘ç»œå‡½æ•°", { c: Color.White });
            
            LOG("  ğŸ“Š åˆ†æå·¥å…·:", { c: Color.Blue });
            LOG("    nativeAnalyzeSO(soName, showExports, showImports) - åˆ†æSOæ–‡ä»¶", { c: Color.White });
            
            LOG("  âš¡ ä¾¿æ·å‡½æ•°:", { c: Color.Blue });
            LOG("    nativeQuickHookCrypto(algorithm) - å¿«é€ŸHookåŠ å¯†ç®—æ³•", { c: Color.White });
            LOG("    nativeQuickHookNetwork() - å¿«é€ŸHookç½‘ç»œç›¸å…³", { c: Color.White });
            LOG("    nativeQuickAnalyzeApp() - å¿«é€Ÿåˆ†æåº”ç”¨ä¿¡æ¯", { c: Color.White });
            LOG("    nativeEnableAllHooks(showStack) - ä¸€é”®å¯ç”¨æ‰€æœ‰Native Hook", { c: Color.White });
            LOG("      ç¤ºä¾‹: nativeEnableAllHooks(1)  // å¯ç”¨æ‰€æœ‰å¹¶æ˜¾ç¤ºè°ƒç”¨æ ˆ", { c: Color.Yellow });
        }
    } else {
        LOG("\\nğŸ”§ Native Hook å·¥å…·: æœªåŠ è½½", { c: Color.Yellow });
        LOG("  è¿è¡Œ loadNativeSupport() å°è¯•åŠ è½½", { c: Color.Gray });
    }
    
    LOG("\\nğŸ¯ æ™ºèƒ½å·¥å…·:", { c: Color.Green });
    LOG("  smartTrace(target, options) / intelligentHookDispatcher(targetIdentifier, hookOptions) - æ™ºèƒ½è¯†åˆ«å¹¶Hookç›®æ ‡", { c: Color.White });
    LOG("    ç¤ºä¾‹: smartTrace('com.example.MainActivity')", { c: Color.Yellow });
    LOG("    æ–°ç¤ºä¾‹: intelligentHookDispatcher('com.example.MainActivity', {enableStackTrace: true})", { c: Color.Yellow });
    LOG("    ç¤ºä¾‹: smartTrace('malloc', {showArgs: true})", { c: Color.Yellow });
    
    LOG("\\nğŸ› ï¸  å·¥å…·å‡½æ•°:", { c: Color.Green });
    LOG("  printStack() / printJavaCallStack(showComplete, maxLines) - æ‰“å°Javaè°ƒç”¨æ ˆ", { c: Color.White });
    if (typeof printNativeStack !== 'undefined') {
        LOG("  printNativeStack() - æ‰“å°Nativeè°ƒç”¨æ ˆ", { c: Color.White });
    }
    
    LOG("\\nğŸ”¥ é«˜çº§è¿½è¸ªåŠŸèƒ½ (åŸºäº r0tracer):", { c: Color.Red });
    LOG("  bypassTracerPidDetection() - ç»•è¿‡TracerPidåè°ƒè¯•æ£€æµ‹", { c: Color.White });
    LOG("  inspectObjectFields(obj, context) - æ£€æŸ¥å¯¹è±¡æ‰€æœ‰å­—æ®µè¯¦æƒ…", { c: Color.White });
    LOG("  advancedMethodTracing(method, enableFields, enableColor) - é«˜çº§æ–¹æ³•è¿½è¸ª", { c: Color.White });
    LOG("    ç¤ºä¾‹: advancedMethodTracing('com.example.Class.method', true, true)", { c: Color.Yellow });
    LOG("  batchHookWithFilters(whitelist, blacklist, targetClass) - æ‰¹é‡Hookï¼ˆé»‘ç™½åå•è¿‡æ»¤ï¼‰", { c: Color.White });
    LOG("    ç¤ºä¾‹: batchHookWithFilters('com.example', 'test', null)", { c: Color.Yellow });
    LOG("  hookAllApplicationClasses(strictFilter) - Hookæ‰€æœ‰åº”ç”¨ä¸šåŠ¡ç±»", { c: Color.White });
    LOG("    ç¤ºä¾‹: hookAllApplicationClasses(true)", { c: Color.Yellow });
    
    LOG("\\nğŸ“‹ ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ (å‚è€ƒ objection):", { c: Color.Red });
    LOG("  jobs() - æ˜¾ç¤ºæ‰€æœ‰æ´»è·ƒçš„Hookä»»åŠ¡", { c: Color.White });
    LOG("  job(id) - æ˜¾ç¤ºæŒ‡å®šä»»åŠ¡çš„è¯¦ç»†ä¿¡æ¯", { c: Color.White });
    LOG("  kill(id) - å–æ¶ˆæŒ‡å®šçš„Hookä»»åŠ¡", { c: Color.White });
    LOG("  killall() - å–æ¶ˆæ‰€æœ‰Hookä»»åŠ¡", { c: Color.White });
    LOG("  pause(id) / resume(id) - æš‚åœ/æ¢å¤ä»»åŠ¡", { c: Color.White });
    LOG("  jobstats() - æ˜¾ç¤ºä»»åŠ¡ç»Ÿè®¡ä¿¡æ¯", { c: Color.White });
    LOG("  history() - æ˜¾ç¤ºä»»åŠ¡å†å²è®°å½•", { c: Color.White });
    LOG("  cleanup() - æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡", { c: Color.White });
    LOG("  jobhelp() - æ˜¾ç¤ºä»»åŠ¡ç®¡ç†è¯¦ç»†å¸®åŠ©", { c: Color.White });
    
    LOG("\\nğŸ¯ å¸¦ä»»åŠ¡ç®¡ç†çš„Hookå‡½æ•°:", { c: Color.Green });
    LOG("  traceMethodWithJob(method, showStack, retVal) - å¯ç®¡ç†çš„æ–¹æ³•Hook", { c: Color.White });
    LOG("  traceClassWithJob(className) - å¯ç®¡ç†çš„ç±»Hook", { c: Color.White });
    LOG("  advancedMethodTracingWithJob(method, fields, color) - å¯ç®¡ç†çš„é«˜çº§è¿½è¸ª", { c: Color.White });
    LOG("  batchHookWithJob(whitelist, blacklist, targetClass) - å¯ç®¡ç†çš„æ‰¹é‡Hook", { c: Color.White });
    LOG("    ç¤ºä¾‹: var jobId = traceMethodWithJob('com.example.Class.method', true)", { c: Color.Yellow });
    LOG("          kill(jobId)  // å–æ¶ˆè¿™ä¸ªHook", { c: Color.Yellow });
    LOG("  LOG(message, options) - å¢å¼ºçš„æ—¥å¿—è¾“å‡º", { c: Color.White });
    LOG("  loadNativeSupport() - åŠ è½½Native Hookå·¥å…·", { c: Color.White });
    LOG("  help() - æ˜¾ç¤ºæ­¤å¸®åŠ©", { c: Color.White });
    
    LOG("\\nğŸ¯ å®æˆ˜ä½¿ç”¨æ–¹æ¡ˆ:", { c: Color.Green });
    LOG("  ğŸ“‹ æ–°æ‰‹å…¥é—¨:", { c: Color.Blue });
    LOG("    1. é¦–å…ˆæŸ¥æ‰¾ç›®æ ‡ç±»: findClasses('MainActivity', true)", { c: Color.White });
    LOG("    2. è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•: traceClass('com.example.MainActivity')", { c: Color.White });
    LOG("    3. é‡ç‚¹æ–¹æ³•è¯¦ç»†åˆ†æ: traceMethod('com.example.MainActivity.onCreate', true)", { c: Color.White });
    LOG("    4. æœç´¢æ•æ„Ÿå­—ç¬¦ä¸²: findStrInMap('password', 1)", { c: Color.White });
    
    LOG("\\n  ğŸ” é€†å‘åˆ†æå·¥ä½œæµ:", { c: Color.Blue });
    LOG("    ç¬¬ä¸€æ­¥ - åº”ç”¨åˆ†æ:", { c: Color.Cyan });
    LOG("      enumAllClasses('com.yourapp')  // æšä¸¾åº”ç”¨æ‰€æœ‰ç±»", { c: Color.Yellow });
    LOG("      nativeQuickAnalyzeApp()         // å¿«é€Ÿåˆ†æSOå’ŒJNI", { c: Color.Yellow });
    LOG("      hookLoadLibrary(1)              // ç›‘æ§åŠ¨æ€åº“åŠ è½½", { c: Color.Yellow });
    
    LOG("\\n    ç¬¬äºŒæ­¥ - å…³é”®ç‚¹å®šä½:", { c: Color.Cyan });
    LOG("      hookBase64(1)                   // ç›‘æ§Base64ç¼–è§£ç ", { c: Color.Yellow });
    LOG("      hookJSONObject(1)               // ç›‘æ§JSONæ•°æ®", { c: Color.Yellow });
    LOG("      hookURL(1)                      // ç›‘æ§ç½‘ç»œè¯·æ±‚", { c: Color.Yellow });
    LOG("      hookEditText(1)                 // ç›‘æ§ç”¨æˆ·è¾“å…¥", { c: Color.Yellow });
    
    LOG("\\n    ç¬¬ä¸‰æ­¥ - æ·±å…¥Hookåˆ†æ:", { c: Color.Cyan });
    LOG("      advancedMethodTracing('target.method', true, true)  // é«˜çº§è¿½è¸ª", { c: Color.Yellow });
    LOG("      batchHookWithFilters('com.app', 'test', null)       // æ‰¹é‡Hook", { c: Color.Yellow });
    LOG("      inspectObjectFields(obj, 'loginæ£€æŸ¥')                // å¯¹è±¡å­—æ®µåˆ†æ", { c: Color.Yellow });
    
    LOG("\\n  ğŸ” å®‰å…¨ç»•è¿‡å®ä¾‹:", { c: Color.Blue });
    LOG("    åè°ƒè¯•ç»•è¿‡:", { c: Color.Cyan });
    LOG("      bypassTracerPidDetection()      // ç»•è¿‡TracerPidæ£€æµ‹", { c: Color.Yellow });
    LOG("      nativeHookAntiDebug(1)          // Hookåè°ƒè¯•å‡½æ•°", { c: Color.Yellow });
    
    LOG("\\n    SSL Pinningç»•è¿‡:", { c: Color.Cyan });
    LOG("      nativeHookCryptoFunctions('all', 1)  // Hookæ‰€æœ‰åŠ å¯†å‡½æ•°", { c: Color.Yellow });
    LOG("      hookURL(1)                           // ç›‘æ§HTTPSè¯·æ±‚", { c: Color.Yellow });
    
    LOG("\\n    Rootæ£€æµ‹ç»•è¿‡:", { c: Color.Cyan });
    LOG("      findClasses('root', true)            // æŸ¥æ‰¾Rootæ£€æµ‹ç›¸å…³ç±»", { c: Color.Yellow });
    LOG("      traceMethod('com.app.RootChecker.isRooted', true)  // Hookæ£€æµ‹æ–¹æ³•", { c: Color.Yellow });
    
    LOG("\\n  ğŸ“‹ ä»»åŠ¡ç®¡ç†æœ€ä½³å®è·µ:", { c: Color.Blue });
    LOG("    é•¿æœŸç›‘æ§åœºæ™¯:", { c: Color.Cyan });
    LOG("      var id1 = traceMethodWithJob('login.method', true)   // åˆ›å»ºå¯ç®¡ç†Hook", { c: Color.Yellow });
    LOG("      var id2 = traceClassWithJob('NetworkHandler')        // ç½‘ç»œç±»ç›‘æ§", { c: Color.Yellow });
    LOG("      jobs()                                              // æŸ¥çœ‹æ‰€æœ‰æ´»è·ƒä»»åŠ¡", { c: Color.Yellow });
    LOG("      jobstats()                                          // æŸ¥çœ‹ä»»åŠ¡ç»Ÿè®¡", { c: Color.Yellow });
    LOG("      kill(id1)                                           // å–æ¶ˆç‰¹å®šä»»åŠ¡", { c: Color.Yellow });
    
    LOG("\\n  ğŸ’¡ é«˜çº§æŠ€å·§:", { c: Color.Blue });
    LOG("    ç»„åˆä½¿ç”¨ç¤ºä¾‹:", { c: Color.Cyan });
    LOG("      // å®Œæ•´çš„ç™»å½•æµç¨‹åˆ†æ", { c: Color.Gray });
    LOG("      smartTrace('LoginActivity')     // æ™ºèƒ½è¯†åˆ«ç™»å½•ç›¸å…³", { c: Color.Yellow });
    LOG("      hookEditText(1)                // ç›‘æ§ç”¨æˆ·è¾“å…¥", { c: Color.Yellow });
    LOG("      hookBase64(1)                  // ç›‘æ§å¯†ç ç¼–ç ", { c: Color.Yellow });
    LOG("      findStrInMap('token', 1)       // ç›‘æ§tokenç”Ÿæˆ", { c: Color.Yellow });
    
    LOG("\\n    æ€§èƒ½ä¼˜åŒ–:", { c: Color.Cyan });
    LOG("      // ä½¿ç”¨é»‘ç™½åå•å‡å°‘Hookæ•°é‡", { c: Color.Gray });
    LOG("      batchHookWithFilters('com.target', 'test,debug', 'LoginActivity')  // ç²¾å‡†Hook", { c: Color.Yellow });
    LOG("      // æš‚åœä¸éœ€è¦çš„ä»»åŠ¡", { c: Color.Gray });
    LOG("      pause(taskId)                  // æš‚åœä»»åŠ¡è€Œä¸åˆ é™¤", { c: Color.Yellow });
    
    LOG("\\nğŸ’¡ ä½¿ç”¨æç¤º:", { c: Color.Green });
    LOG("  â€¢ ä½¿ç”¨ Tab é”®è‡ªåŠ¨è¡¥å…¨å‡½æ•°åå’ŒåŒ…å", { c: Color.Gray });
    LOG("  â€¢ æ”¯æŒé“¾å¼è°ƒç”¨å’Œå¤æ‚è¡¨è¾¾å¼", { c: Color.Gray });
    LOG("  â€¢ è¾“å…¥ q æˆ– exit é€€å‡ºç¨‹åº", { c: Color.Gray });
    LOG("  â€¢ æ‰€æœ‰å‡½æ•°éƒ½æ”¯æŒä¸°å¯Œçš„å‚æ•°é€‰é¡¹", { c: Color.Gray });
    LOG("  â€¢ å»ºè®®å…ˆä½¿ç”¨smartTrace()è¿›è¡Œæ™ºèƒ½è¯†åˆ«", { c: Color.Gray });
    LOG("  â€¢ é•¿æœŸç›‘æ§å»ºè®®ä½¿ç”¨å¸¦Jobçš„å‡½æ•°ç‰ˆæœ¬", { c: Color.Gray });
    LOG("\\n" + "=".repeat(75) + "\\n", { c: Color.Gray });
}

// RPC exports for interactive shell
rpc.exports = {
    // å¸®åŠ©å’Œæ ¸å¿ƒ
    help: help,
    eval: function(code) {
        try {
            return eval(code);
        } catch (e) {
            LOG("âŒ é”™è¯¯: " + e.message, { c: Color.Red });
            return null;
        }
    },
    
    // Java Hook å‡½æ•°
    traceClass: traceClass,
    hookAllMethodsInJavaClass: hookAllMethodsInJavaClass,
    traceMethod: traceMethod,
    hookJavaMethodWithTracing: hookJavaMethodWithTracing,
    findClasses: findClasses,
    enumAllClasses: enumAllClasses,
    describeJavaClass: describeJavaClass,
    printStack: printStack,
    findTragetClassLoader: findTragetClassLoader,
    findTargetClassLoaderForClass: findTargetClassLoaderForClass,
    printJavaCallStack: printJavaCallStack,
    findStrInMap: findStrInMap,
    
    // é«˜çº§è¿½è¸ªåŠŸèƒ½ï¼ˆåŸºäº r0tracerï¼‰
    bypassTracerPidDetection: typeof bypassTracerPidDetection !== 'undefined' ? bypassTracerPidDetection : function() { 
        LOG("bypassTracerPidDetection éœ€è¦é«˜çº§è¿½è¸ªå·¥å…·", { c: Color.Yellow }); 
    },
    inspectObjectFields: typeof inspectObjectFields !== 'undefined' ? inspectObjectFields : function() { 
        LOG("inspectObjectFields éœ€è¦é«˜çº§è¿½è¸ªå·¥å…·", { c: Color.Yellow }); 
    },
    advancedMethodTracing: typeof advancedMethodTracing !== 'undefined' ? advancedMethodTracing : function() { 
        LOG("advancedMethodTracing éœ€è¦é«˜çº§è¿½è¸ªå·¥å…·", { c: Color.Yellow }); 
    },
    batchHookWithFilters: typeof batchHookWithFilters !== 'undefined' ? batchHookWithFilters : function() { 
        LOG("batchHookWithFilters éœ€è¦é«˜çº§è¿½è¸ªå·¥å…·", { c: Color.Yellow }); 
    },
    hookAllApplicationClasses: typeof hookAllApplicationClasses !== 'undefined' ? hookAllApplicationClasses : function() { 
        LOG("hookAllApplicationClasses éœ€è¦é«˜çº§è¿½è¸ªå·¥å…·", { c: Color.Yellow }); 
    },
    
    // ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ
    jobs: typeof jobs !== 'undefined' ? jobs : function() { 
        LOG("jobs éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    job: typeof job !== 'undefined' ? job : function() { 
        LOG("job éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    kill: typeof kill !== 'undefined' ? kill : function() { 
        LOG("kill éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    killall: typeof killall !== 'undefined' ? killall : function() { 
        LOG("killall éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    pause: typeof pause !== 'undefined' ? pause : function() { 
        LOG("pause éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    resume: typeof resume !== 'undefined' ? resume : function() { 
        LOG("resume éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    jobstats: typeof jobstats !== 'undefined' ? jobstats : function() { 
        LOG("jobstats éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    history: typeof history !== 'undefined' ? history : function() { 
        LOG("history éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    cleanup: typeof cleanup !== 'undefined' ? cleanup : function() { 
        LOG("cleanup éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    jobhelp: typeof jobhelp !== 'undefined' ? jobhelp : function() { 
        LOG("jobhelp éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    
    // å¸¦ä»»åŠ¡ç®¡ç†çš„Hookå‡½æ•°
    traceMethodWithJob: typeof traceMethodWithJob !== 'undefined' ? traceMethodWithJob : function() { 
        LOG("traceMethodWithJob éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    traceClassWithJob: typeof traceClassWithJob !== 'undefined' ? traceClassWithJob : function() { 
        LOG("traceClassWithJob éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    advancedMethodTracingWithJob: typeof advancedMethodTracingWithJob !== 'undefined' ? advancedMethodTracingWithJob : function() { 
        LOG("advancedMethodTracingWithJob éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    batchHookWithJob: typeof batchHookWithJob !== 'undefined' ? batchHookWithJob : function() { 
        LOG("batchHookWithJob éœ€è¦ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ", { c: Color.Yellow }); 
    },
    
    // å®šä½Hookå‡½æ•°
    hookBase64: typeof hookBase64 !== 'undefined' ? hookBase64 : function() { 
        LOG("hookBase64 éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookToast: typeof hookToast !== 'undefined' ? hookToast : function() { 
        LOG("hookToast éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookJSONObject: typeof hookJSONObject !== 'undefined' ? hookJSONObject : function() { 
        LOG("hookJSONObject éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookHashMap: typeof hookHashMap !== 'undefined' ? hookHashMap : function() { 
        LOG("hookHashMap éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookEditText: typeof hookEditText !== 'undefined' ? hookEditText : function() { 
        LOG("hookEditText éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookArrayList: typeof hookArrayList !== 'undefined' ? hookArrayList : function() { 
        LOG("hookArrayList éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookLoadLibrary: typeof hookLoadLibrary !== 'undefined' ? hookLoadLibrary : function() { 
        LOG("hookLoadLibrary éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookNewStringUTF: typeof hookNewStringUTF !== 'undefined' ? hookNewStringUTF : function() { 
        LOG("hookNewStringUTF éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookFileOperations: typeof hookFileOperations !== 'undefined' ? hookFileOperations : function() { 
        LOG("hookFileOperations éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookLog: typeof hookLog !== 'undefined' ? hookLog : function() { 
        LOG("hookLog éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    hookURL: typeof hookURL !== 'undefined' ? hookURL : function() { 
        LOG("hookURL éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    enableAllHooks: typeof enableAllHooks !== 'undefined' ? enableAllHooks : function() { 
        LOG("enableAllHooks éœ€è¦å®šä½Hookå·¥å…·", { c: Color.Yellow }); 
    },
    
    // æ™ºèƒ½å·¥å…·
    smartTrace: smartTrace,
    intelligentHookDispatcher: intelligentHookDispatcher,
    loadNativeSupport: loadNativeSupport,
    
    // Native Hook å‡½æ•° (å¦‚æœå¯ç”¨)
    nativeHookNativeFunction: typeof nativeHookNativeFunction !== 'undefined' ? nativeHookNativeFunction : function() { 
        LOG("Native Hook å·¥å…·æœªåŠ è½½ï¼Œè¯·è¿è¡Œ loadNativeSupport()"); 
    },
    nativeFindModules: typeof nativeFindModules !== 'undefined' ? nativeFindModules : function() { 
        LOG("nativeFindModules éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeFindExports: typeof nativeFindExports !== 'undefined' ? nativeFindExports : function() { 
        LOG("nativeFindExports éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeSearchMemory: typeof nativeSearchMemory !== 'undefined' ? nativeSearchMemory : function() { 
        LOG("nativeSearchMemory éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    printNativeStack: typeof printNativeStack !== 'undefined' ? printNativeStack : function() { 
        LOG("printNativeStack éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    
    // é«˜çº§Native Hookå‡½æ•°
    nativeHookDlopenFamily: typeof nativeHookDlopenFamily !== 'undefined' ? nativeHookDlopenFamily : function() { 
        LOG("nativeHookDlopenFamily éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeHookJNIFunctions: typeof nativeHookJNIFunctions !== 'undefined' ? nativeHookJNIFunctions : function() { 
        LOG("nativeHookJNIFunctions éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeHookCryptoFunctions: typeof nativeHookCryptoFunctions !== 'undefined' ? nativeHookCryptoFunctions : function() { 
        LOG("nativeHookCryptoFunctions éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeHookNetworkFunctions: typeof nativeHookNetworkFunctions !== 'undefined' ? nativeHookNetworkFunctions : function() { 
        LOG("nativeHookNetworkFunctions éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeHookAntiDebug: typeof nativeHookAntiDebug !== 'undefined' ? nativeHookAntiDebug : function() { 
        LOG("nativeHookAntiDebug éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeAnalyzeSO: typeof nativeAnalyzeSO !== 'undefined' ? nativeAnalyzeSO : function() { 
        LOG("nativeAnalyzeSO éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeEnableAllHooks: typeof nativeEnableAllHooks !== 'undefined' ? nativeEnableAllHooks : function() { 
        LOG("nativeEnableAllHooks éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeQuickHookCrypto: typeof nativeQuickHookCrypto !== 'undefined' ? nativeQuickHookCrypto : function() { 
        LOG("nativeQuickHookCrypto éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeQuickHookNetwork: typeof nativeQuickHookNetwork !== 'undefined' ? nativeQuickHookNetwork : function() { 
        LOG("nativeQuickHookNetwork éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    nativeQuickAnalyzeApp: typeof nativeQuickAnalyzeApp !== 'undefined' ? nativeQuickAnalyzeApp : function() { 
        LOG("nativeQuickAnalyzeApp éœ€è¦ Native Hook å·¥å…·", { c: Color.Yellow }); 
    },
    
    // å·¥å…·å‡½æ•°
    uniqBy: uniqBy,
    bytesToString: bytesToString,
    LOG: LOG,
    Color: Color
};

// è‡ªåŠ¨åŒ…è£…å‡½æ•°ï¼Œæ·»åŠ ä»»åŠ¡ç®¡ç†
if (typeof HookJobManager !== 'undefined') {
    LOG("\\nğŸ¤– å¯ç”¨è‡ªåŠ¨ä»»åŠ¡è¿½è¸ª...", { c: Color.Blue });
    
    // åŒ…è£…å‰©ä½™çš„å®šä½Hookå‡½æ•°ï¼ˆå·²ä¿®æ”¹çš„ä¸éœ€è¦é‡å¤åŒ…è£…ï¼‰
    var remainingHookFunctions = [
        'hookJSONObject', 'hookHashMap', 'hookEditText', 'hookArrayList', 
        'hookLoadLibrary', 'hookNewStringUTF', 'hookFileOperations', 
        'hookURL', 'enableAllHooks'
    ];
    
    remainingHookFunctions.forEach(function(funcName) {
        if (typeof global[funcName] === 'function') {
            var originalFunc = global[funcName];
            global[funcName] = function() {
                var args = Array.prototype.slice.call(arguments);
                var taskId = HookJobManager.autoRegisterHook(funcName, args);
                try {
                    var result = originalFunc.apply(this, args);
                    return taskId;
                } catch (e) {
                    if (taskId) {
                        var job = HookJobManager.getJob(taskId);
                        if (job) job.updateStatus('failed', e);
                    }
                    throw e;
                }
            };
        }
    });
    
    // åŒ…è£…Java Hookå‡½æ•°
    var javaHookFunctions = ['traceMethod', 'findClasses', 'enumAllClasses', 'describeJavaClass'];
    javaHookFunctions.forEach(function(funcName) {
        if (typeof global[funcName] === 'function') {
            var originalFunc = global[funcName];
            global[funcName] = function() {
                var args = Array.prototype.slice.call(arguments);
                var taskId = HookJobManager.autoRegisterHook(funcName, args);
                try {
                    var result = originalFunc.apply(this, args);
                    return taskId;
                } catch (e) {
                    if (taskId) {
                        var job = HookJobManager.getJob(taskId);
                        if (job) job.updateStatus('failed', e);
                    }
                    throw e;
                }
            };
        }
    });
    
    LOG("âœ… è‡ªåŠ¨ä»»åŠ¡è¿½è¸ªå·²å¯ç”¨", { c: Color.Green });
} else {
    LOG("âš ï¸  ä»»åŠ¡ç®¡ç†å™¨æœªåŠ è½½ï¼Œè·³è¿‡è‡ªåŠ¨ä»»åŠ¡è¿½è¸ª", { c: Color.Yellow });
}

LOG("\\nğŸš€ fridac å·²å°±ç»ª!", { c: Color.Green });
LOG("ğŸ’¡ è¾“å…¥ help() æŸ¥çœ‹å¯ç”¨å‡½æ•°", { c: Color.Cyan });
LOG("ğŸ’¡ è¾“å…¥ q æˆ– exit é€€å‡ºç¨‹åº\\n", { c: Color.Cyan });

}); // End of Java.perform
'''
    
    return js_content

class FridacSession:
    """Frida session management class"""
    
    def __init__(self):
        self.session = None
        self.script = None
        self.device = None
        self.target_process = None
        self.running = False
        
    def on_message(self, message, data):
        """Handle messages from Frida script with enhanced logging"""
        if message['type'] == 'send':
            payload = message['payload']
            if RICH_AVAILABLE:
                # Try to format JavaScript output nicely
                if isinstance(payload, str) and (payload.startswith('{') or payload.startswith('[')):
                    try:
                        import json
                        formatted = json.loads(payload)
                        console.print(formatted)
                    except:
                        console.print(payload)
                else:
                    console.print(payload)
            else:
                print(payload)
        elif message['type'] == 'error':
            log_error("è„šæœ¬é”™è¯¯: {}".format(message['description']))
    
    def connect_to_app(self, app_name, spawn_mode=False):
        """Connect to target app"""
        try:
            # Get USB device with progress indicator
            if RICH_AVAILABLE:
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=console
                ) as progress:
                    task = progress.add_task("æ­£åœ¨è¿æ¥è®¾å¤‡...", total=None)
                    self.device = frida.get_usb_device()
                    progress.update(task, description="âœ… è®¾å¤‡è¿æ¥æˆåŠŸ")
            else:
                log_info("æ­£åœ¨è¿æ¥è®¾å¤‡...")
                self.device = frida.get_usb_device()
            
            log_success("è¿æ¥åˆ°è®¾å¤‡: {}".format(self.device))
            
            if spawn_mode:
                # Spawn mode
                log_info("å¯åŠ¨åº”ç”¨: {}".format(app_name))
                pid = self.device.spawn([app_name])
                self.target_process = self.device.attach(pid)
                self.device.resume(pid)
                log_success("åº”ç”¨å·²å¯åŠ¨ (PID: {})".format(pid))
            else:
                # Attach mode  
                log_info("è¿æ¥åˆ°åº”ç”¨: {}".format(app_name))
                self.target_process = self.device.attach(app_name)
                log_success("å·²è¿æ¥åˆ°è¿è¡Œä¸­çš„åº”ç”¨")
            
            # Load and create script
            log_info("æ­£åœ¨åŠ è½½ Frida è„šæœ¬...")
            js_script = create_frida_script()
            if not js_script:
                return False
                
            self.script = self.target_process.create_script(js_script)
            self.script.on('message', self.on_message)
            self.script.load()
            
            self.running = True
            log_success("Frida è„šæœ¬å·²åŠ è½½ï¼Œä¼šè¯å»ºç«‹æˆåŠŸ!")
            return True
            
        except frida.ProcessNotFoundError:
            log_error("æ‰¾ä¸åˆ°è¿›ç¨‹: {}".format(app_name))
            return False
        except frida.ServerNotRunningError:
            log_error("Frida æœåŠ¡å™¨æœªè¿è¡Œï¼Œè¯·ç¡®ä¿è®¾å¤‡å·²è¿æ¥å¹¶å¯åŠ¨ frida-server")
            return False
        except Exception as e:
            log_error("è¿æ¥å¤±è´¥: {}".format(e))
            return False
    
    def execute_js(self, js_code):
        """Execute JavaScript code with enhanced error handling"""
        if not self.script:
            log_error("æ²¡æœ‰æ´»åŠ¨çš„è„šæœ¬ä¼šè¯")
            return
            
        try:
            # Handle special exit commands
            if js_code.strip().lower() in ['q', 'quit', 'exit']:
                self.running = False
                return
            
            # Show what we're executing for complex commands
            if len(js_code) > 50 or '\n' in js_code:
                log_debug("æ‰§è¡Œ JavaScript: {}...".format(js_code[:50]))
            
            # Execute the JavaScript code through RPC
            result = self.script.exports.eval(js_code)
            
        except Exception as e:
            log_error("æ‰§è¡Œé”™è¯¯: {}".format(e))
    
    def disconnect(self):
        """Disconnect from target with graceful cleanup"""
        self.running = False
        if self.script:
            try:
                self.script.unload()
                log_debug("è„šæœ¬å·²å¸è½½")
            except:
                pass
        if self.target_process:
            try:
                self.target_process.detach()
                log_debug("è¿›ç¨‹å·²åˆ†ç¦»")
            except:
                pass
        log_success("å·²æ–­å¼€è¿æ¥")

def run_frida_session(spawn_mode=False, target_package=None, force_show_apps=False):
    """Run Frida session with interactive shell"""
    
    if force_show_apps or not target_package:
        # Find target app interactively
        target_app = find_target_app()
        if not target_app:
            return
    else:
        # Use specified package
        target_app = target_package
        log_info("ä½¿ç”¨æŒ‡å®šçš„åŒ…å: {}".format(target_app))
    
    session = FridacSession()
    
    # Setup signal handler for clean exit
    def signal_handler(sig, frame):
        log_info("æ­£åœ¨é€€å‡º...")
        session.disconnect()
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    # Connect to app
    if not session.connect_to_app(target_app, spawn_mode):
        return
    
    # Interactive loop
    setup_history()
    
    # Show beautiful interactive mode banner
    if RICH_AVAILABLE:
        console.print()
        
        # Create interactive mode panel
        interactive_panel = Panel(
            "[bold green]ğŸ¯ äº¤äº’æ¨¡å¼å·²å¯ç”¨[/bold green]\n\n"
            "â€¢ ä½¿ç”¨ [cyan]Tab[/cyan] é”®è‡ªåŠ¨è¡¥å…¨å‡½æ•°åå’Œç±»å\n"
            "â€¢ ç›´æ¥è°ƒç”¨ JS å‡½æ•°è¿›è¡Œ Hook æ“ä½œ\n"
            "â€¢ è¾“å…¥ [yellow]help()[/yellow] æŸ¥çœ‹æ‰€æœ‰å¯ç”¨å‡½æ•°\n"
            "â€¢ è¾“å…¥ [red]q[/red] æˆ– [red]exit[/red] é€€å‡ºç¨‹åº",
            title="ğŸš€ fridac äº¤äº’å¼ Shell",
            border_style="green",
            padding=(1, 2)
        )
        # console.print(interactive_panel)
        
        # Show examples
        example_table = Table(title="ğŸ“ å¸¸ç”¨å‘½ä»¤ç¤ºä¾‹", box=ROUNDED, show_header=True, header_style="bold blue")
        example_table.add_column("åŠŸèƒ½è¯´æ˜", style="green", width=35)
        example_table.add_column("ä½¿ç”¨ç¤ºä¾‹", style="cyan", width=55)
        
        examples = [
            ("ğŸ›ï¸ è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•", "[cyan]traceClass[/cyan]('com.example.MainActivity')"),
            ("ğŸ›ï¸ è·Ÿè¸ªç±»çš„æ‰€æœ‰æ–¹æ³•ï¼ˆæ–°å‡½æ•°ï¼‰", "[cyan]hookAllMethodsInJavaClass[/cyan]('com.example.MainActivity')"),
            ("ğŸ¯ è·Ÿè¸ªç‰¹å®šæ–¹æ³•", "[cyan]traceMethod[/cyan]('com.example.Class.method')"),
            ("ğŸ¯ è·Ÿè¸ªç‰¹å®šæ–¹æ³•ï¼ˆæ–°å‡½æ•°ï¼‰", "[cyan]hookJavaMethodWithTracing[/cyan]('com.example.Class.method', true)"),
            ("ğŸ”¥ é«˜çº§æ–¹æ³•è¿½è¸ªï¼ˆå­—æ®µ+å½©è‰²ï¼‰", "[cyan]advancedMethodTracing[/cyan]('com.example.Class.method', true, true)"),
            ("ğŸ“¦ æ‰¹é‡Hookï¼ˆé»‘ç™½åå•ï¼‰", "[cyan]batchHookWithFilters[/cyan]('com.example', 'test', null)"),
            ("ğŸš€ Hookæ‰€æœ‰åº”ç”¨ç±»", "[cyan]hookAllApplicationClasses[/cyan](true)"),
            ("ğŸ”’ ç»•è¿‡åè°ƒè¯•æ£€æµ‹", "[cyan]bypassTracerPidDetection[/cyan]()"),
            ("ğŸ“‹ å¯ç®¡ç†çš„æ–¹æ³•Hook", "var id = [cyan]traceMethodWithJob[/cyan]('com.example.Class.method', true)"),
            ("ğŸ“Š æŸ¥çœ‹æ‰€æœ‰æ´»è·ƒä»»åŠ¡", "[cyan]jobs[/cyan]()"),
            ("âŒ å–æ¶ˆæŒ‡å®šä»»åŠ¡", "[cyan]kill[/cyan](id)"),
            ("â“ ä»»åŠ¡ç®¡ç†å¸®åŠ©", "[cyan]jobhelp[/cyan]()"),
            ("ğŸ” æŸ¥æ‰¾åŒ¹é…çš„ç±»å¹¶æ˜¾ç¤ºæ–¹æ³•", "[cyan]findClasses[/cyan]('MainActivity', true)"),
            ("ğŸ“‹ æšä¸¾åŒ…ä¸‹çš„æ‰€æœ‰ç±»", "[cyan]enumAllClasses[/cyan]('com.example')"),
            ("ğŸ“š æ˜¾ç¤ºå®Œæ•´å¸®åŠ©ä¿¡æ¯", "[cyan]help[/cyan]()")
        ]
        
        for desc, cmd in examples:
            example_table.add_row(desc, cmd)
        
        # console.print()
        # console.print(example_table)
        # console.print()
        
        # Show completion helper
        completer = FridacCompleter()
        completer.show_completion_help()
        
    else:
        print("\n" + "="*60)
        print("ğŸ¯ è¿›å…¥äº¤äº’æ¨¡å¼ - æ™ºèƒ½è¡¥å…¨å·²å¯ç”¨")
        print("ğŸ’¡ ä½¿ç”¨ Tab é”®è‡ªåŠ¨è¡¥å…¨å‡½æ•°åå’Œç±»å")
        print("ğŸ“ å¯ä»¥ç›´æ¥è°ƒç”¨ JS å‡½æ•°ï¼Œä¾‹å¦‚:")
        print("   traceClass('com.example.MainActivity')")
        print("   hookAllMethodsInJavaClass('com.example.MainActivity')  # æ–°å‡½æ•°å")
        print("   traceMethod('com.example.Class.method')")
        print("   hookJavaMethodWithTracing('com.example.Class.method', true)  # æ–°å‡½æ•°å")
        print("   advancedMethodTracing('com.example.Class.method', true, true)  # é«˜çº§è¿½è¸ª")
        print("   batchHookWithFilters('com.example', 'test', null)  # æ‰¹é‡Hook")
        print("   bypassTracerPidDetection()  # ç»•è¿‡åè°ƒè¯•")
        print("   var id = traceMethodWithJob('com.example.Class.method', true)  # å¯ç®¡ç†Hook")
        print("   jobs()  # æŸ¥çœ‹ä»»åŠ¡")
        print("   kill(id)  # å–æ¶ˆä»»åŠ¡")
        print("   findClasses('MainActivity', true)")
        print("ğŸ“š è¾“å…¥ help() æŸ¥çœ‹æ‰€æœ‰å¯ç”¨å‡½æ•°")
        print("ğŸšª è¾“å…¥ q æˆ– exit é€€å‡º")
        print("="*60 + "\n")
    
    while session.running:
        try:
            # Get user input with rich prompt if available
            if RICH_AVAILABLE:
                user_input = Prompt.ask(
                    "[bold cyan]fridac[/bold cyan][dim]>[/dim]",
                    default="",
                    show_default=False
                ).strip()
            else:
                user_input = input("fridac> ").strip()
            
            if not user_input:
                continue
                
            # Handle exit commands
            if user_input.lower() in ['q', 'quit', 'exit']:
                log_info("æ­£åœ¨é€€å‡º...")
                break
            
            # Execute JavaScript code
            session.execute_js(user_input)
            
        except KeyboardInterrupt:
            log_info("æ­£åœ¨é€€å‡º...")
            break
        except EOFError:
            log_info("æ­£åœ¨é€€å‡º...")
            break
    
    # Clean up
    session.disconnect()

def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description='fridac - Enhanced Frida CLI tool with interactive JavaScript shell',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  fridac                                    # Auto-attach to frontmost app (smart mode)
  fridac -a                                 # Show apps list for selection
  fridac -f com.example.app                 # Spawn app and attach
  fridac -p com.example.app                 # Attach to specific package
  fridac --spawn com.example.app            # Spawn app and attach (same as -f)
        '''
    )
    
    parser.add_argument('-f', '--package', type=str,
                       help='Specify package name to spawn and attach')
    
    parser.add_argument('-p', '--attach-package', type=str,
                       help='Specify package name to attach (without spawning)')
    
    parser.add_argument('-a', '--apps', action='store_true',
                       help='Show apps list for selection (original behavior)')
    
    parser.add_argument('--spawn', type=str,
                       help='Spawn mode with package name (same as -f)')
    
    parser.add_argument('--version', action='version', 
                       version='fridac 1.0 (Frida {})'.format(get_frida_version()))
    
    args = parser.parse_args()
    
    # Determine target package and mode
    target_package = None
    spawn_mode = False
    force_show_apps = False
    
    if args.package:  # -f com.example.app
        target_package = args.package
        spawn_mode = True
    elif args.spawn:  # --spawn com.example.app
        target_package = args.spawn
        spawn_mode = True
    elif args.attach_package:  # -p com.example.app
        target_package = args.attach_package
        spawn_mode = False
    elif args.apps:  # -a (show apps list)
        force_show_apps = True
    else:
        # Default behavior: try to attach to frontmost app
        frontmost_id, frontmost_name = get_frontmost_app()
        if frontmost_id:
            target_package = frontmost_id
            spawn_mode = False
            log_success("æ£€æµ‹åˆ°å‰å°åº”ç”¨: {} ({})".format(frontmost_name, frontmost_id))
            log_info("å°†è‡ªåŠ¨è¿æ¥åˆ°æ­¤åº”ç”¨ï¼Œå¦‚éœ€é€‰æ‹©å…¶ä»–åº”ç”¨è¯·ä½¿ç”¨ 'fridac -a'")
        else:
            log_info("æ²¡æœ‰æ£€æµ‹åˆ°å‰å°åº”ç”¨ï¼Œæ˜¾ç¤ºåº”ç”¨åˆ—è¡¨...")
            force_show_apps = True
    
    # Detect and display Python environment info
    env_info = detect_python_environment()
    
    # Show beautiful banner and environment info
    show_banner()
    
    if RICH_AVAILABLE:
        # Create environment info table
        env_table = Table(title="ğŸ”§ ç¯å¢ƒä¿¡æ¯", box=SIMPLE, show_header=True, header_style="bold blue")
        env_table.add_column("ç»„ä»¶", style="cyan", min_width=10)
        env_table.add_column("ç‰ˆæœ¬/è·¯å¾„", style="green", min_width=30)
        env_table.add_column("çŠ¶æ€", style="yellow", min_width=15)
        
        # Python info
        python_status = "âœ… æ­£å¸¸" if env_info['version'] != 'unknown' else "âŒ å¼‚å¸¸"
        env_table.add_row("Python", f"{env_info['version']} ({env_info['executable']})", python_status)
        
        # Pyenv info
        if env_info.get('using_pyenv') and 'pyenv_version' in env_info:
            env_table.add_row("pyenv", env_info['pyenv_version'], "âœ… æ¿€æ´»")
        else:
            env_table.add_row("pyenv", "ç³»ç»Ÿ Python", "âšª æœªä½¿ç”¨")
        
        # Frida info
        frida_status = "âœ… å¯ç”¨" if env_info['frida_version'] != 'unknown' else "âŒ æœªå®‰è£…"
        env_table.add_row("Frida", env_info['frida_version'], frida_status)
        
        console.print()
        console.print(env_table)
        console.print()
    else:
        log_info("Python: {} ({})".format(env_info['version'], env_info['executable']))
        if env_info.get('using_pyenv') and 'pyenv_version' in env_info:
            log_info("pyenv: {}".format(env_info['pyenv_version']))
        elif not env_info.get('using_pyenv'):
            log_info("ç¯å¢ƒ: ç³»ç»Ÿ Python (æœªä½¿ç”¨ pyenv)")
        log_info("Frida: {}".format(env_info['frida_version']))
    
    # # Validate Python-Frida compatibility
    # python_version = env_info['version']
    # frida_version = env_info['frida_version']
    
    # if python_version.startswith('3.6') and '14.' in frida_version:
    #     print("âœ… Python 3.6.x + Frida 14.x - é…ç½®æ­£ç¡®")
    # elif python_version.startswith('3.8') and '16.' in frida_version:
    #     print("âœ… Python 3.8.x + Frida 16.x - é…ç½®æ­£ç¡®")
    # else:
    #     print("âš ï¸  å½“å‰é…ç½®: Python {} + Frida {}".format(python_version, frida_version))
    #     print("ğŸ’¡ å»ºè®®é…ç½®: Python 3.6.8 + Frida 14.x æˆ– Python 3.8.2 + Frida 16.x")
    
    try:
        run_frida_session(spawn_mode=spawn_mode, target_package=target_package, force_show_apps=force_show_apps)
    except KeyboardInterrupt:
        log_info("ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        log_error("è¿è¡Œå‡ºé”™: {}".format(e))
        if not RICH_AVAILABLE:
            log_warning("å»ºè®®å®‰è£… rich è·å¾—æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ: pip install rich")

if __name__ == '__main__':
    main()